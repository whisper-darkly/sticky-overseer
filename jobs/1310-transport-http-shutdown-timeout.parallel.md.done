---
title: Fix transport.go: HTTP server shutdown must use bounded context, not context.Background()
created: 2026-02-21
origin: Post-audit improvement plan — Medium severity finding M9; srv.Shutdown(context.Background()) can block indefinitely if WebSocket connections are not draining
priority: medium
complexity: low
notes:
  - Affects both tcpTransport and unixTransport types
  - shutdown paths currently unbounded — main.go has 15s orchestration but transport has no deadline
  - context already imported; only need to add context.WithTimeout calls
  - Use parent ctx parameter instead of context.Background() for cleaner cancellation propagation
---

Follow exactly and without stopping:

## Task: Fix HTTP Server Shutdown Timeout in transport.go

## Background & Context

During post-audit code review, a medium severity finding (M9) was identified: both tcpTransport.Listen() and unixTransport.Listen() call srv.Shutdown(context.Background()) which has no deadline. If a WebSocket client fails to drain properly, the HTTP server shutdown blocks indefinitely. While main.go orchestrates hub.Shutdown with a 15-second context, the transport layer has no matching deadline constraint, creating a window where the entire graceful shutdown can hang.

The root cause is using context.Background() (unbounded) instead of a context with a timeout. The fix is straightforward: derive a context with a 10-second timeout from the parent ctx parameter (which is already cancelled by main.go's orchestration), ensuring the transport shutdown never blocks longer than the allotted window.

## Problem Description

Current behavior:
- tcpTransport.Listen() calls srv.Shutdown(context.Background()) at line ~183
- unixTransport.Listen() calls srv.Shutdown(context.Background()) at line ~349
- Both use unbounded context — no timeout or deadline
- If a WebSocket connection does not drain, shutdown hangs indefinitely
- main.go's orchestration uses a 15-second context, but transport shutdown ignores it

Example failure scenario:
- A WebSocket client connects but does not close properly
- srv.Shutdown() waits indefinitely for all handlers to complete
- Main process hangs during shutdown, eventually timing out at OS level
- Logs may show no clear indication of which component is blocking

## Implementation Plan

1. Locate tcpTransport.Listen() method in transport.go (around line 183)
   - Find the defer statement or explicit call to srv.Shutdown(context.Background())

2. Replace the unbounded shutdown call with a timeout-bounded version:
   ```go
   shutdownCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
   defer cancel()
   srv.Shutdown(shutdownCtx)
   ```

3. Locate unixTransport.Listen() method in transport.go (around line 349)
   - Apply the same timeout-bounded shutdown pattern

4. Verify context imports are present (should already be imported)

5. Verify the parent ctx parameter is used (not creating a new context.Background())
   - Using the parent ctx ensures cancellation signals propagate correctly

6. Run go vet to check for any context-related issues

7. Run the full test suite to ensure no regressions:
   ```bash
   go test -race ./...
   ```

## Technical Requirements

- File paths: /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/transport.go
- Dependencies: context package (already imported)
- Commands needed: go vet, go test -race
- Build verification: make build
- Reference: tcpTransport.Listen() line ~183, unixTransport.Listen() line ~349

## Success Criteria

- Both tcpTransport and unixTransport shutdown paths use bounded 10-second timeout contexts
- The timeout context is derived from parent ctx parameter (not context.Background())
- No compiler errors or missing imports
- go vet passes without context-related warnings
- go test -race ./... passes all tests
- make build succeeds
- Code follows existing style (defer cancel() pattern)

## Expected Outcome

HTTP server shutdown in both transport types will no longer block indefinitely. Even if WebSocket clients fail to drain, the transport shutdown will timeout after 10 seconds, allowing the main process to continue its graceful shutdown sequence and complete within the 15-second orchestration window.

## Reference Information

- Modified file: /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/transport.go
- Context package: already imported (verify imports section)
- Parent context: ctx parameter passed to Listen() method (from main.go orchestration)
- Main orchestration: main.go graceful shutdown with 15-second deadline
- Audit finding: M9 - shutdown context unbounded
- Related methods: tcpTransport.Listen() and unixTransport.Listen()

## Notes & Warnings

- The 10-second timeout is chosen to leave buffer within main.go's 15-second orchestration window
- Always defer cancel() immediately after context.WithTimeout() to avoid resource leaks
- Use the parent ctx parameter rather than context.Background() to ensure proper cancellation propagation
- The errcheck suppression comment (//nolint:errcheck) can be used if srv.Shutdown() error is intentionally ignored
- Verify no other code in transport.go uses unbounded contexts in critical paths
- After changes, confirm build and test before submitting
