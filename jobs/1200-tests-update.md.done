---
title: Add new test files and update existing tests for the refactored architecture
created: 2026-02-21
origin: sticky-overseer architecture refactor - comprehensive test coverage
priority: high
complexity: high
notes:
  - This is the most extensive test work in the refactor
  - New test files for every major component
  - Existing tests must be updated to work with new architecture
  - No tests should use sleep-based synchronization
  - All tests must pass with go test -race
---

Follow exactly and without stopping:

## Task: Add new test files and update existing tests for the refactored architecture

## Background & Context

The refactored sticky-overseer has introduced multiple new major components (transport, actions, pool, config) that require comprehensive test coverage. Existing tests must be updated to work with the new architecture (Conn interface instead of *websocket.Conn, ActionHandlers instead of command strings, etc.).

This job creates test files for all new components and updates existing test files to work with the refactored code. The goal is to maintain or improve test coverage while ensuring all tests pass with `-race` flag.

## Problem Description

Current state:
- No tests for config.go, actions.go, handler implementations, pool.go, transport.go
- hub_test.go and other existing tests reference old API (pinnedCommand, command strings, etc.)
- store_test.go tests don't cover v2→v3 migration
- No integration tests for new message types

After completion:
- All new components have comprehensive unit and integration tests
- Existing tests updated to work with new architecture
- Coverage maintained at same level as before
- All tests pass with `go test -race ./...`
- No data races in concurrent code

## Implementation Plan

### Part 1: New Test Files

#### config_test.go (NEW FILE)

```go
// Test loadConfig with missing file → defaults
func TestLoadConfig_MissingFile(t *testing.T) {
    cfg, err := loadConfig("/nonexistent/path.yaml")
    // Should not error - use defaults
    // cfg.Listen == ":8080"
    // cfg.DB == "./overseer.db"
    // cfg.Actions is empty or has defaults
}

// Test loadConfig with valid YAML
func TestLoadConfig_ValidYAML(t *testing.T) {
    yaml := `
listen: ":9090"
db: /tmp/test.db
log_file: /tmp/test.log
trusted_cidrs:
  - 127.0.0.1/8
  - ::1/128
task_pool:
  limit: 10
  queue_size: 100
  excess: requeue
  max_age: 5m
actions:
  echo:
    type: exec
    command: /bin/echo
    params:
      msg:
        default: hello
        validate: "size(msg) > 0"
`
    // Write to temp file, call loadConfig
    // Verify all fields populated correctly
}

// Test ParamSpec YAML parsing with null
func TestParamSpec_YAML_Null(t *testing.T) {
    var ps ParamSpec
    yaml.Unmarshal([]byte("null"), &ps)
    // ps.Default should be nil
    // ps.Validate should be ""
}

// Test ParamSpec YAML parsing with string
func TestParamSpec_YAML_String(t *testing.T) {
    var ps ParamSpec
    yaml.Unmarshal([]byte("\"hello\""), &ps)
    // ps.Default should be "hello"
    // ps.Validate should be ""
}

// Test ParamSpec YAML parsing with map
func TestParamSpec_YAML_Map(t *testing.T) {
    yaml := `
default: "test"
validate: "size(this) > 0"
`
    // Parse and verify Default and Validate fields populated
}

// Test RetryPolicy duration string parsing
func TestRetryPolicy_YAML_Duration(t *testing.T) {
    yaml := `
restart_delay: 5s
error_window: 60s
error_threshold: 3
`
    var rp RetryPolicy
    // Parse and verify RestartDelay == 5*time.Second
}
```

#### actions_test.go (NEW FILE)

```go
// Test registering an action factory
func TestRegisterFactory(t *testing.T) {
    // Register a test factory
    // Verify it appears in registry
}

// Test buildActionHandlers with unknown handler type
func TestBuildActionHandlers_UnknownType(t *testing.T) {
    cfg := &Config{
        Actions: map[string]*ActionConfig{
            "bad": {Type: "unknown_handler"},
        },
    }
    // buildActionHandlers should return error
}

// Test buildActionHandlers with factory error
func TestBuildActionHandlers_CreateError(t *testing.T) {
    // Register factory that returns error
    cfg := &Config{
        Actions: map[string]*ActionConfig{
            "bad": {Type: "test_error"},
        },
    }
    // buildActionHandlers should propagate error
}

// Test merge retry policy - zero values don't override
func TestMergeRetryPolicy_ZeroDoesNotOverride(t *testing.T) {
    global := &RetryPolicy{RestartDelay: 5 * time.Second}
    action := &RetryPolicy{}  // zero values
    result := mergeRetryPolicy(global, action)
    // result.RestartDelay should be 5*time.Second (from global)
}

// Test merge retry policy - non-zero values override
func TestMergeRetryPolicy_OverrideApplied(t *testing.T) {
    global := &RetryPolicy{RestartDelay: 5 * time.Second}
    action := &RetryPolicy{RestartDelay: 10 * time.Second}
    result := mergeRetryPolicy(global, action)
    // result.RestartDelay should be 10*time.Second (from action)
}

// Test CEL program compilation - empty expression
func TestCompileCELProgram_Empty(t *testing.T) {
    prog, err := compileCELProgram("")
    // Should not error
    // prog should be nil or no-op program
}

// Test CEL program compilation - valid expression
func TestCompileCELProgram_Valid(t *testing.T) {
    prog, err := compileCELProgram("size(x) > 5")
    // Should not error
    // prog should be executable
}

// Test CEL program compilation - invalid expression
func TestCompileCELProgram_Invalid(t *testing.T) {
    prog, err := compileCELProgram("invalid!!!syntax")
    // Should return error
}

// Test CEL boolean evaluation - passes
func TestEvalCELBool_Pass(t *testing.T) {
    prog, _ := compileCELProgram("x > 5")
    result := evalCELBool(prog, map[string]any{"x": 10})
    // result should be true
}

// Test CEL boolean evaluation - fails
func TestEvalCELBool_Fail(t *testing.T) {
    prog, _ := compileCELProgram("x > 5")
    result := evalCELBool(prog, map[string]any{"x": 3})
    // result should be false
}
```

#### handler_exec_test.go (NEW FILE)

```go
// Test exec handler Describe returns non-nil Params
func TestExecHandler_Describe_ParamsNonNil(t *testing.T) {
    handler := newExecHandler(&ActionConfig{...})
    info := handler.Describe()
    // info.Params should not be nil (at least empty map)
}

// Test exec handler Describe populated from config
func TestExecHandler_Describe_PopulatedFromConfig(t *testing.T) {
    cfg := &ActionConfig{
        Params: map[string]*ParamSpec{
            "msg": {
                Default: "hello",
                Validate: "size(msg) > 0",
            },
        },
    }
    handler := newExecHandler(cfg)
    info := handler.Describe()
    // info.Params["msg"] should have Default and Validate
}

// Test exec handler Validate - required param missing
func TestExecHandler_Validate_Required(t *testing.T) {
    cfg := &ActionConfig{
        Params: map[string]*ParamSpec{
            "msg": {}, // required (no default)
        },
    }
    handler := newExecHandler(cfg)
    err := handler.Validate(map[string]string{})
    // err should indicate missing "msg"
}

// Test exec handler Validate - optional param gets default
func TestExecHandler_Validate_Optional_Default(t *testing.T) {
    cfg := &ActionConfig{
        Params: map[string]*ParamSpec{
            "msg": {Default: "world"},
        },
    }
    handler := newExecHandler(cfg)
    params := map[string]string{}
    handler.Validate(params)
    // params["msg"] should be set to "world"
}

// Test exec handler Validate - CEL validation passes
func TestExecHandler_Validate_CEL_Pass(t *testing.T) {
    cfg := &ActionConfig{
        Params: map[string]*ParamSpec{
            "msg": {Validate: "size(msg) > 0"},
        },
    }
    handler := newExecHandler(cfg)
    err := handler.Validate(map[string]string{"msg": "hello"})
    // err should be nil
}

// Test exec handler Validate - CEL validation fails
func TestExecHandler_Validate_CEL_Fail(t *testing.T) {
    cfg := &ActionConfig{
        Params: map[string]*ParamSpec{
            "msg": {Validate: "size(msg) > 0"},
        },
    }
    handler := newExecHandler(cfg)
    err := handler.Validate(map[string]string{"msg": ""})
    // err should indicate validation failure
}

// Test exec handler Start - template rendering
func TestExecHandler_Start_Template(t *testing.T) {
    cfg := &ActionConfig{
        Command: "/bin/echo",
        CommandTemplate: "/bin/echo {{.msg}}",
    }
    handler := newExecHandler(cfg)
    worker, err := handler.Start(taskID, map[string]string{"msg": "hello"}, ...)
    // Command should be rendered as "echo hello"
}

// Test exec factory - bad CEL fails at Create time
func TestExecFactory_BadCEL_FailsAtCreate(t *testing.T) {
    cfg := &ActionConfig{
        Type: "exec",
        Params: map[string]*ParamSpec{
            "x": {Validate: "bad!!!syntax"},
        },
    }
    handler, err := execFactory{}.Create("test", cfg)
    // err should indicate CEL compilation error
    // handler should be nil
}
```

#### pool_test.go (NEW FILE - COMPREHENSIVE)

```go
// Implement all pool acceptance tests from job 06:
func TestPool_Unlimited(t *testing.T)
func TestPool_Reject_Overflow(t *testing.T)
func TestPool_Queue_FIFO(t *testing.T)
func TestPool_Queue_LIFO(t *testing.T)
func TestPool_MaxAge_Expiry(t *testing.T)
func TestPool_Displace_True(t *testing.T)
func TestPool_Displace_Prohibit(t *testing.T)
func TestPool_Forced_Preferential(t *testing.T)
func TestPool_Release_Triggers_Queue(t *testing.T)
func TestPool_SetLimits_Excess_Stop(t *testing.T)
func TestPool_SetLimits_Excess_Requeue(t *testing.T)
func TestPool_PurgeQueue_ByAction(t *testing.T)
func TestPool_PurgeQueue_All(t *testing.T)
func TestPool_DrainAll(t *testing.T)

// Example structure:
func TestPool_Unlimited(t *testing.T) {
    pm := NewPoolManager(&PoolConfig{Limit: 0}, nil) // 0 = unlimited
    
    // Acquire many tasks, all should succeed immediately
    for i := 0; i < 100; i++ {
        st, err := pm.Acquire(taskID, "test", false, stopFn, startFn)
        // st should be acquired immediately, not queued
    }
}

func TestPool_Queue_FIFO(t *testing.T) {
    pm := NewPoolManager(&PoolConfig{
        Limit: 1,
        QueueSize: 10,
        Excess: "queue",
        OrderPolicy: "FIFO",
    }, nil)
    
    // Acquire 3 tasks with limit 1
    // First acquired, 2nd and 3rd queued in FIFO order
    // Release first → 2nd acquires (verify order)
}

// ... implement all 14 tests with proper synchronization (channels, WaitGroup, etc.)
```

#### transport_test.go (NEW FILE)

```go
// Test ParseListenAddr - TCP with bare port
func TestParseListenAddr_TCP(t *testing.T) {
    tr, err := ParseListenAddr("8080")
    // err should be nil
    // tr should be tcpTransport{":8080"}
}

// Test ParseListenAddr - TCP with full address
func TestParseListenAddr_TCP_FullAddr(t *testing.T) {
    tr, err := ParseListenAddr("localhost:9090")
    // err should be nil
    // tr should be tcpTransport{"localhost:9090"}
}

// Test ParseListenAddr - STDIO uppercase
func TestParseListenAddr_STDIO_Upper(t *testing.T) {
    tr, err := ParseListenAddr("STDIO")
    // err should be nil
    // tr should be stdioTransport{}
}

// Test ParseListenAddr - STDIO lowercase
func TestParseListenAddr_STDIO_Lower(t *testing.T) {
    tr, err := ParseListenAddr("stdio")
    // err should be nil
    // tr should be stdioTransport{}
}

// Test ParseListenAddr - STDIO mixed case
func TestParseListenAddr_STDIO_Mixed(t *testing.T) {
    tr, err := ParseListenAddr("StDiO")
    // err should be nil
    // tr should be stdioTransport{}
}

// Test ParseListenAddr - Unix absolute path
func TestParseListenAddr_UnixAbsolute(t *testing.T) {
    tr, err := ParseListenAddr("/tmp/test.sock")
    // err should be nil
    // tr should be unixTransport{"/tmp/test.sock"}
}

// Test ParseListenAddr - Unix relative path
func TestParseListenAddr_UnixRelative(t *testing.T) {
    tr, err := ParseListenAddr("./test.sock")
    // err should be nil
    // tr should be unixTransport{"./test.sock"}
}

// Test STDIO transport JSON round-trip
func TestStdioConn_ReadWrite(t *testing.T) {
    // Use io.Pipe for stdin/stdout
    // Create stdioConn wrapping the pipes
    // WriteJSON a test message
    // ReadJSON on the other end
    // Verify round-trip integrity
}

// Test TCP transport connection and upgrade
func TestTCPTransport_Listen(t *testing.T) {
    tr := tcpTransport{addr: ":0"}  // random port
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    connChan, err := tr.Listen(ctx)
    // err should be nil
    
    // Dial and upgrade to WebSocket
    // Verify Conn emitted to channel
    // Send/receive JSON
}

// Test TCP transport IP trust check
func TestTCPTransport_TrustedCheck(t *testing.T) {
    // Create tcpTransport with restricted TrustedNets (loopback only)
    // Attempt upgrade from non-loopback address
    // Verify upgrade rejected (403 or connection refused)
    // Note: may be difficult to test without actual network; skip if not feasible
}
```

### Part 2: Update Existing Test Files

#### hub_test.go (MAJOR UPDATE)

```go
// Update newHubEnv helper to accept *Config instead of pinnedCmd
func newHubEnv(t *testing.T, cfg *Config) (*sql.DB, *Hub) {
    // Create temp DB
    // If cfg is nil, create default config with test actions
    // Default test actions:
    //   - "echo": exec handler, command=/bin/echo, required param "msg"
    //   - "sleep": exec handler, command=/bin/sleep, optional param "duration" default "60"
    //   - "false": exec handler, command=/bin/false, no params
    // Build action handlers from config
    // Create hub with actions and pool
    // Return db and hub
}

// Delete old tests that used pinnedCommand:
// - TestPinnedCommand_Allowed
// - TestPinnedCommand_Mismatch
// etc.

// Add new tests:

func TestStart_UnknownAction(t *testing.T) {
    _, h := newHubEnv(t, nil)
    
    // Send start with unknown action
    msg := IncomingMessage{
        Type: "start",
        Action: "nonexistent",
        Params: map[string]string{},
    }
    
    // Call h.handleStart
    // Verify error response received
}

func TestStart_MissingRequiredParam(t *testing.T) {
    _, h := newHubEnv(t, nil)
    
    // Send start with exec action but missing "msg" param
    msg := IncomingMessage{
        Type: "start",
        Action: "echo",
        Params: map[string]string{},  // missing msg
    }
    
    // Call h.handleStart
    // Verify validation error response
}

func TestStart_CELValidationFail(t *testing.T) {
    // Create config with exec action with CEL validation
    cfg := &Config{
        Actions: map[string]*ActionConfig{
            "restricted": {
                Type: "exec",
                Command: "/bin/echo",
                Params: map[string]*ParamSpec{
                    "msg": {Validate: "size(msg) < 5"},
                },
            },
        },
    }
    _, h := newHubEnv(t, cfg)
    
    // Send start with msg="toolong"
    msg := IncomingMessage{
        Type: "start",
        Action: "restricted",
        Params: map[string]string{"msg": "toolong"},
    }
    
    // Call h.handleStart
    // Verify validation error response
}

func TestStart_Queued(t *testing.T) {
    // Create config with pool limit=1
    cfg := &Config{
        TaskPool: &PoolConfig{Limit: 1, QueueSize: 10},
        Actions: map[string]*ActionConfig{
            "sleep": {Type: "exec", Command: "/bin/sleep", ...},
        },
    }
    _, h := newHubEnv(t, cfg)
    
    // Send 2 starts for "sleep"
    // First acquired immediately
    // Second queued
    // Verify "queued" response for second
}

func TestStop_DequeuedTask(t *testing.T) {
    // Create pool with limit=1, queue 2nd task
    // Send stop for 2nd (queued) task
    // Verify "dequeued" event broadcast
    // Verify task removed from queue
}

func TestDescribe_AllActions(t *testing.T) {
    _, h := newHubEnv(t, nil)
    
    msg := IncomingMessage{
        Type: "describe",
        Action: "",  // empty = all actions
    }
    
    // Call h.handleDescribe
    // Verify response includes all registered actions (echo, sleep, false)
    // Each ActionInfo has Name field set
}

func TestDescribe_SingleAction(t *testing.T) {
    _, h := newHubEnv(t, nil)
    
    msg := IncomingMessage{
        Type: "describe",
        Action: "echo",
    }
    
    // Call h.handleDescribe
    // Verify response includes only "echo" action
}

func TestPoolInfo_Global(t *testing.T) {
    _, h := newHubEnv(t, nil)
    
    msg := IncomingMessage{
        Type: "pool_info",
        Action: "",  // empty = global
    }
    
    // Call h.handlePoolInfo
    // Verify response includes total running and queue depth
}

func TestPoolInfo_PerAction(t *testing.T) {
    _, h := newHubEnv(t, nil)
    
    msg := IncomingMessage{
        Type: "pool_info",
        Action: "echo",
    }
    
    // Call h.handlePoolInfo
    // Verify response includes counts for "echo" action only
}

func TestPurge_ByAction(t *testing.T) {
    // Queue multiple tasks for different actions
    // Send purge with specific action
    // Verify only that action's queue cleared
    // Verify dequeued events broadcast
}

func TestPurge_All(t *testing.T) {
    // Queue multiple tasks for different actions
    // Send purge with empty action
    // Verify all queues cleared
}

func TestSetPool_ReducesLimit(t *testing.T) {
    _, h := newHubEnv(t, nil)
    
    // Send set_pool to reduce limit
    msg := IncomingMessage{
        Type: "set_pool",
        Action: "echo",
        Limit: 2,
        QueueSize: 5,
    }
    
    // Call h.handleSetPool
    // Verify response success
    // Verify broadcast to all clients
}

func TestBroadcast_AllClients(t *testing.T) {
    // Create multiple mock connections
    // Send broadcast message
    // Verify all connections receive it
    // Verify uses Conn.WriteLock() mechanism
}
```

#### store_test.go (UPDATE)

```go
// Add new test for v2→v3 migration
func TestMigrateV2ToV3(t *testing.T) {
    // Create temp SQLite DB with v2 schema
    // INSERT sample task with command="echo", args="[\"hello\"]"
    // Call openDB on temp DB (triggers migration)
    // Verify:
    //   - schema_version = 3
    //   - task.action = "echo"
    //   - task.params = {}
    //   - no "args" or "command" columns exist
}

// Update existing tests to use Action+Params:
// - TestCreateTask: use action, params instead of command, args
// - TestGetTask: verify Action and Params fields
// - TestUpdateTask: update Action+Params
// - TestListTasks: verify Action+Params in results

// Example update:
func TestCreateTask(t *testing.T) {
    db := setupTestDB(t)
    
    rec := &TaskRecord{
        TaskID: "test-1",
        Action: "exec",  // WAS: Command: "echo"
        Params: map[string]string{"msg": "hello"},  // WAS: Args: []string{"hello"}
        // ... other fields
    }
    
    err := createTask(db, rec)
    // err should be nil
    
    // Verify in DB
    retrieved, _ := getTask(db, "test-1")
    assert.Equal(t, retrieved.Action, "exec")
    assert.Equal(t, retrieved.Params["msg"], "hello")
}
```

#### main_test.go (UPDATE)

```go
// Update any tests that reference old flags
// Update -command references to action/config references
// Test new flags: -version, -help, --list-handlers
// Test config loading
// Test ENV overrides
```

### Part 3: General Requirements

- All tests in all files must:
  - Pass with `go test -race ./...`
  - Use channels/WaitGroup for synchronization, not time.Sleep
  - Clean up goroutines and temp files in defer blocks
  - Not leak DB connections or resources
  - Have clear test names describing what they test
  - Include comments explaining non-obvious test logic

- Test utilities:
  - newHubEnv helper creates fully functional test environment
  - setupTestDB helper creates temp SQLite database
  - Mock handler for testing pool behavior
  - Mock transport for unit testing Hub message dispatch

## Technical Requirements

- Test file locations:
  - `/home/mmulligan/Development/whisper-darkly-github/sticky-overseer/config_test.go` (NEW)
  - `/home/mmulligan/Development/whisper-darkly-github/sticky-overseer/actions_test.go` (NEW)
  - `/home/mmulligan/Development/whisper-darkly-github/sticky-overseer/handler_exec_test.go` (NEW)
  - `/home/mmulligan/Development/whisper-darkly-github/sticky-overseer/pool_test.go` (NEW)
  - `/home/mmulligan/Development/whisper-darkly-github/sticky-overseer/transport_test.go` (NEW)
  - `/home/mmulligan/Development/whisper-darkly-github/sticky-overseer/hub_test.go` (UPDATE)
  - `/home/mmulligan/Development/whisper-darkly-github/sticky-overseer/store_test.go` (UPDATE)
  - `/home/mmulligan/Development/whisper-darkly-github/sticky-overseer/main_test.go` (UPDATE)

- Testing packages: standard library testing, testify/assert for assertions
- No external mocking frameworks (use simple interfaces and mock structs)

## Success Criteria

- `go test -race ./...` passes with 0 failures and 0 data races
- All new test functions defined and passing
- All existing tests updated to work with new architecture
- Code coverage maintained at approximately same level as before refactor
- No test uses time.Sleep as primary synchronization (channels/WaitGroup only)
- All tests properly clean up resources (defer close, defer cleanup)
- Test names clearly describe what they test

## Expected Outcome

Comprehensive test suite covering all new components and updated existing tests. All tests pass with race detector. Full coverage of happy paths, validation failures, error cases, and concurrent scenarios.

## Reference Information

- Testing best practices: Go testing conventions, avoid sleep-based timing
- Sync primitives: sync.WaitGroup, channels for coordination
- Temp files: ioutil.TempFile, defer os.Remove
- Database testing: sql.Open with file:memory: or temp files
- JSON testing: encoding/json for marshaling/unmarshaling

## Notes & Warnings

- Hub tests must properly handle goroutines spawned by handler.Start()
- Pool tests are most complex - carefully design synchronization
- Transport tests may need actual network sockets (use dynamic port allocation)
- Don't hardcode localhost as 127.0.0.1 - use net.SplitHostPort
- Cleanup order matters: close connections before closing DB
- Each test should be independent and runnable in any order
