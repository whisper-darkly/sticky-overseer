---
title: Fix worker.go - process group signaling, scanner error handling, and output buffer size
created: 2026-02-21
origin: Post-audit improvement plan â€” addresses Critical/High findings in worker.go - orphaned child processes when parent is killed, silent scanner failures on large output lines, 5s kill goroutine not cancellable on shutdown
priority: high
complexity: medium
notes:
  - File location: /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/worker.go
  - Changes required in three functions: startWorker(), Stop(), and the scan() closure
  - Must add syscall import (already present in current file)
  - Add stopCh channel field to Worker struct
  - Do NOT build the full project - only verify worker.go syntax after changes
  - Testing will be done in a separate job after all modifications complete
---

Follow exactly and without stopping:

## Task: Fix worker.go Process Management and Output Handling

## Background & Context

During post-audit code review of worker.go, three critical issues were identified:

1. **Orphaned child processes**: The Stop() method only sends signals to the parent process (single PID). Child processes spawned by the worker command are not in the signal delivery scope, causing them to orphan when the parent is killed.

2. **Silent scanner failures**: The scan() goroutine reads from stdout/stderr pipes using bufio.Scanner but never checks scanner.Err() after the loop completes. Large output lines (>64KB, the default buffer) cause the scanner to silently fail, losing output without any error signal to the system.

3. **Non-cancellable kill goroutine**: The 5-second SIGKILL escalation goroutine uses time.Sleep(5s) unconditionally. During graceful shutdown, this goroutine may persist and attempt to signal already-cleaned processes, creating timing issues.

These issues impact production reliability: background processes leak, large output causes silent data loss, and shutdown races occur.

## Problem Description

**Symptom 1 - Orphaned processes**: When a task is stopped, parent process receives SIGTERM but child processes continue running because Stop() uses `w.cmd.Process.Signal(syscall.SIGTERM)` which only targets that single PID.

**Symptom 2 - Silent scanner failure**: Output lines exceeding 64KB cause bufio.Scanner to return error state without scanning. The scan() function continues as if nothing happened because there's no `if err := scanner.Err()` check after the loop.

**Symptom 3 - Non-cancellable kill goroutine**: The goroutine spawned in Stop() at line 171 unconditionally sleeps 5 seconds. If Stop() is called during shutdown, this goroutine can outlive its parent Worker, potentially attempting to kill already-reaped processes.

**Current state**: worker.go has the Worker struct (lines 30-45), startWorker() function (lines 83-159), and Stop() method (lines 161-180). The scan() closure is defined at lines 114-128.

**Discovery**: Found during architecture review and code audit checklist.

## Implementation Plan

### Step 1: Modify Worker struct to add stopCh field

In the Worker struct definition (around line 30-45), add a new field after `intentionalStop`:

```go
type Worker struct {
	PID       int
	TaskID    string
	Command   string
	Args      []string
	State     WorkerState
	StartedAt time.Time
	ExitedAt  *time.Time
	ExitCode  *int

	cmd             *exec.Cmd
	mu              sync.Mutex
	events          []Event
	callbacks       workerCallbacks
	intentionalStop bool
	stopCh          chan struct{} // NEW: signals kill goroutine to proceed/cancel
}
```

### Step 2: Initialize stopCh in startWorker()

In the startWorker() function, where the Worker struct is initialized (around line 98-107), add stopCh initialization:

```go
w := &Worker{
	PID:       cmd.Process.Pid,
	TaskID:    cfg.TaskID,
	Command:   cfg.Command,
	Args:      cfg.Args,
	State:     WorkerRunning,
	StartedAt: time.Now().UTC(),
	cmd:       cmd,
	callbacks: cb,
	stopCh:    make(chan struct{}), // NEW: initialize the stop channel
}
```

### Step 3: Set process group on command before Start()

In startWorker(), BEFORE calling cmd.Start() (currently at line 94), add process group setup:

```go
func startWorker(cfg workerConfig, cb workerCallbacks) (*Worker, error) {
	cmd := exec.Command(cfg.Command, cfg.Args...)
	
	// NEW: Set process group to enable group signaling
	cmd.SysProcAttr = &syscall.SysProcAttr{Setpgid: true}
	
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		return nil, err
	}
	stderr, err := cmd.StderrPipe()
	if err != nil {
		return nil, err
	}

	if err := cmd.Start(); err != nil {
		return nil, err
	}
	// ... rest of function
}
```

### Step 4: Add scanner error handling in scan() closure

In the scan() closure (currently lines 114-128), after the `for scanner.Scan()` loop ends, add error checking. Replace the current scan function with this version:

```go
scan := func(scanner *bufio.Scanner, stream Stream, include bool) {
	defer wg.Done()
	for scanner.Scan() {
		if !include {
			continue
		}
		now := time.Now().UTC()
		line := scanner.Text()
		evt := Event{Type: "output", TaskID: w.TaskID, PID: w.PID, Stream: stream, Data: line, TS: now}
		w.addEvent(evt)
		msg := OutputMessage{Type: "output", TaskID: w.TaskID, PID: w.PID, Stream: stream, Data: line, TS: now}
		w.callbacks.onOutput(msg)
		w.callbacks.logEvent(msg)
	}
	// NEW: Check for scanner errors after loop
	if err := scanner.Err(); err != nil {
		log.Printf("worker task=%s stream=%s scanner error: %v", cfg.TaskID, stream, err)
		w.mu.Lock()
		if w.State == WorkerRunning {
			w.State = WorkerExited
		}
		w.mu.Unlock()
	}
}
```

### Step 5: Increase scanner buffer size

Before the two `go scan()` calls (currently at lines 130-131), increase the buffer size for both stdout and stderr scanners. This requires creating scanner instances with Buffer() calls:

```go
var wg sync.WaitGroup
wg.Add(2)

// Larger buffer to handle long output lines (1MB default, 10MB max)
const scanBufSize = 1 << 20     // 1MB
const scanMaxSize = 10 << 20    // 10MB

// Pipes must always be drained even when output is filtered, to prevent
// the child process from blocking on a full pipe buffer.
scan := func(scanner *bufio.Scanner, stream Stream, include bool) {
	defer wg.Done()
	for scanner.Scan() {
		if !include {
			continue
		}
		now := time.Now().UTC()
		line := scanner.Text()
		evt := Event{Type: "output", TaskID: w.TaskID, PID: w.PID, Stream: stream, Data: line, TS: now}
		w.addEvent(evt)
		msg := OutputMessage{Type: "output", TaskID: w.TaskID, PID: w.PID, Stream: stream, Data: line, TS: now}
		w.callbacks.onOutput(msg)
		w.callbacks.logEvent(msg)
	}
	if err := scanner.Err(); err != nil {
		log.Printf("worker task=%s stream=%s scanner error: %v", cfg.TaskID, stream, err)
		w.mu.Lock()
		if w.State == WorkerRunning {
			w.State = WorkerExited
		}
		w.mu.Unlock()
	}
}

// Create scanners and set large buffer BEFORE scanning
stdoutScanner := bufio.NewScanner(stdout)
stdoutScanner.Buffer(make([]byte, scanBufSize), scanMaxSize)
go scan(stdoutScanner, StreamStdout, cfg.IncludeStdout)

stderrScanner := bufio.NewScanner(stderr)
stderrScanner.Buffer(make([]byte, scanBufSize), scanMaxSize)
go scan(stderrScanner, StreamStderr, cfg.IncludeStderr)
```

### Step 6: Update Stop() method with process group signaling and cancellable kill

Replace the entire Stop() method (lines 161-180) with this version that:
- Signals the entire process group (children included)
- Makes the kill goroutine cancellable via the stopCh

```go
func (w *Worker) Stop() {
	w.mu.Lock()
	if w.State != WorkerRunning || w.cmd.Process == nil {
		w.mu.Unlock()
		return
	}
	w.intentionalStop = true
	w.mu.Unlock()

	// Send SIGTERM to entire process group (negative PID)
	// This ensures all child processes are signaled, not just parent
	pgid, err := syscall.Getpgid(w.cmd.Process.Pid)
	if err == nil {
		_ = syscall.Kill(-pgid, syscall.SIGTERM)
	} else {
		_ = w.cmd.Process.Signal(syscall.SIGTERM)
	}

	// Cancellable kill goroutine: wait 5s or until stopCh is closed
	go func() {
		select {
		case <-time.After(5 * time.Second):
			// 5 seconds elapsed, escalate to SIGKILL
		case <-w.stopCh:
			// Stop was called again or process already exited, cancel the escalation
			return
		}

		w.mu.Lock()
		running := w.State == WorkerRunning
		w.mu.Unlock()

		if running {
			pgid, err := syscall.Getpgid(w.cmd.Process.Pid)
			if err == nil {
				_ = syscall.Kill(-pgid, syscall.SIGKILL)
			} else {
				_ = w.cmd.Process.Kill()
			}
		}
	}()

	// Signal the kill goroutine immediately if Stop is called multiple times
	close(w.stopCh)
}
```

## Technical Requirements

- File to modify: /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/worker.go
- Required import: syscall (already present at line 8)
- Dependencies: bufio, sync, time, os/exec, log (all already imported)
- Constants to define: scanBufSize (1 << 20 = 1MB), scanMaxSize (10 << 20 = 10MB)
- Scanner methods needed: scanner.Buffer(buf, maxSize), scanner.Err()
- Syscall functions: syscall.Getpgid(), syscall.Kill(), syscall.SIGTERM, syscall.SIGKILL
- Unix process group concept: negative PID in Kill() targets entire group

## Success Criteria

After all modifications:

1. Worker struct contains stopCh field initialized in startWorker()
2. cmd.SysProcAttr is set with Setpgid: true before cmd.Start()
3. Both stdout and stderr scanners have Buffer() called with 1MB/10MB sizes
4. scan() closure checks scanner.Err() after loop and logs on error
5. Stop() method uses process group signaling with syscall.Getpgid() and syscall.Kill(-pgid, ...)
6. Kill goroutine is cancellable via select on w.stopCh
7. File parses without syntax errors when checked with `go fmt`
8. Import section still contains syscall and all required packages

## Expected Outcome

When these changes are complete:

- Child processes spawned by commands will be terminated when parent is stopped (no orphans)
- Large output lines up to 10MB will be handled correctly instead of silently failing
- Kill goroutine will immediately exit if Stop() is called during shutdown (no races)
- Error conditions during output scanning are logged and worker state is updated

## Reference Information

- Current worker.go line ranges:
  - Worker struct: lines 30-45
  - startWorker(): lines 83-159
  - scan() closure: lines 114-128
  - Stop() method: lines 161-180
  - Process group concept: signals sent to -pgid target all processes in group

- Relevant constants and types already defined:
  - ringBufferSize = 100 (line 12)
  - WorkerState type (defined elsewhere, used in worker.go)
  - Stream type with StreamStdout, StreamStderr (used at lines 122, 124)

- Test verification will occur in separate job (1400-worker-tests)

## Implementation Notes

1. **Process group setup**: Setting Setpgid: true before cmd.Start() ensures the child inherits it; this must happen BEFORE Start()

2. **Scanner buffer**: The Buffer(buf, maxSize) call must happen BEFORE any Scan() calls. Pre-allocate the buffer to avoid repeated allocations.

3. **Error handling semantics**: When scanner.Err() triggers, the process may still be running. We update local Worker state but let cmd.Wait() goroutine handle the actual process state.

4. **Kill goroutine cancellation**: The select statement allows either timeout OR stopCh close to trigger. Multiple close() calls on stopCh are safe in Go.

5. **Fallback paths**: Both Getpgid and Kill operations have fallback paths (signal single PID, use Process.Kill) for systems where process groups may not work.

6. **Mutex scope**: The stopCh close() happens AFTER mu.Unlock() in Stop() to avoid holding the lock during channel operations.

When complete, verify with:
```bash
cd /home/mmulligan/Development/whisper-darkly-github/sticky-overseer
go fmt worker.go  # Check formatting
go vet worker.go  # Check for obvious errors (note: vet may not catch all issues until full build)
```

Do NOT run `make build` or `go test ./...` yet - those will be done in the test job to catch any integration issues.

