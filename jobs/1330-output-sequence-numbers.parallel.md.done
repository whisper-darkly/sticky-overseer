---
title: Add monotonic sequence numbers to OutputMessage for gap detection on reconnect
created: 2026-02-21
origin: Post-audit architecture review — reconnecting clients receive truncated ring buffer replay with no indication of missed events. Per-task sequence numbers allow clients to detect gaps and understand data loss during reconnection windows.
priority: medium
complexity: medium
notes:
  - Sequence numbers are per-task and monotonically increasing from 1
  - Ring buffer holds 100 events; verbose processes overflow it frequently
  - Must protect outputSeq with task.mu to prevent races
  - Events struct in worker.go must be updated to carry Seq value through ring buffer
  - Replay path must reconstruct OutputMessage with correct Seq values
---

Follow exactly and without stopping:

## Task: Add monotonic sequence numbers to OutputMessage for gap detection on reconnect

## Background & Context

During post-audit architecture review, we identified a critical gap in the reconnection model: when a client disconnects and reconnects, they receive a replay of the last 100 events from the ring buffer. However, if the process produced more than 100 lines of output while disconnected, the client has no way to know which events were missed. This can lead to confusion about process behavior and hidden data loss.

Per-task monotonic sequence numbers allow clients to detect gaps: if they see output lines with Seq values [1, 2, 3, 5, 6], they immediately know line 4 was lost due to ring buffer overflow.

The sequence numbers must be per-task (not global) because sticky-overseer can manage multiple concurrent tasks, and clients need independent gap detection for each task.

## Problem Description

Current state:
- OutputMessage struct has: Type, TaskID, PID, Stream, Data, TS
- No sequence number field exists
- Clients cannot distinguish between "no events" and "events were lost"
- Ring buffer (100 slots) overflows on verbose processes
- Replay sends whatever is left in the buffer with no indication of loss

Specific symptom: A reconnecting client receives 50 output lines but doesn't know if the process produced 50 total lines or 150 lines with 100 dropped due to overflow.

Current workaround: None — clients assume all available events are present.

Discovery: Identified during architecture audit in issue/PR discussing reconnection robustness and client reliability.

## Implementation Plan

1. **Update OutputMessage struct in messages.go**
   - Add `Seq int64 \`json:"seq"\`` field (per-task monotonic sequence number starting at 1)
   - Document that Seq is set by Hub when output is produced

2. **Update Task struct in hub.go**
   - Add `outputSeq int64` field to track the sequence counter
   - Protect with existing `task.mu` (Mutex)
   - Initialize to 0 (first output will increment to 1)

3. **Update Event struct in worker.go**
   - Add `Seq int64` field to Event struct
   - This allows the ring buffer to carry Seq values through storage and replay

4. **Increment sequence in workerCB() onOutput closure (hub.go)**
   - When output is received in the onOutput callback:
     - Lock the task with `task.mu.Lock()`
     - Increment `task.outputSeq++`
     - Assign to `msg.Seq = task.outputSeq`
     - Unlock with `task.mu.Unlock()`
   - Then broadcast the stamped message
   - Example code pattern:
     ```go
     task.mu.Lock()
     task.outputSeq++
     msg.Seq = task.outputSeq
     task.mu.Unlock()
     ```

5. **Update ring buffer storage in worker.go**
   - When events are stored in the ring buffer, the Event struct now includes Seq
   - Ensure Seq is populated when event is created and stored

6. **Verify replay path in handleReplay (hub.go)**
   - Replay reconstructs OutputMessage from Event structs in ring buffer
   - Ensure Seq value from Event is included in reconstructed OutputMessage
   - Events should naturally carry Seq values through the replay process

7. **Build and test**
   - Run `go build ./...` to ensure no compilation errors
   - Verify all files compile: messages.go, hub.go, worker.go, store.go, main.go
   - Test that OutputMessage unmarshals correctly with Seq field

## Technical Requirements

File paths involved:
- /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/messages.go
- /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/hub.go
- /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/worker.go

Dependencies:
- sync.Mutex (already used in Task struct)
- int64 for sequence numbers (supports up to 9+ quintillion events per task)

Commands needed:
- `go build ./...` to verify compilation
- `go vet ./...` for static analysis
- Reference: CLAUDE.md build instructions: `make build`

## Success Criteria

1. OutputMessage includes Seq field marshaling to JSON
2. Each task maintains its own outputSeq counter, protected by task.mu
3. Every OutputMessage sent has a monotonically increasing Seq value starting at 1 per task
4. Ring buffer events carry Seq values through storage and replay
5. Replay path correctly includes Seq in reconstructed OutputMessage
6. `go build ./...` compiles without errors
7. `go vet ./...` shows no issues
8. JSON output includes "seq" field in all OutputMessage instances

## Expected Outcome

Clients can now detect output gaps by examining Seq values in the OutputMessage stream. If a client sees Seq [1, 2, 3, 10], it knows events 4-9 were lost. This provides transparency about data loss and helps diagnose issues when ring buffer overflows occur during high-volume output.

## Reference Information

Key files involved:
- Task struct definition: /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/hub.go (contains Task struct)
- OutputMessage definition: /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/messages.go
- Event struct and ring buffer: /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/worker.go
- WorkerCallbacks and onOutput closure: /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/hub.go (workerCB function)
- Replay handler: handleReplay() in /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/hub.go

Build command: `make build` or `go build ./...`

Architecture documentation: /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/CLAUDE.md describes the ring buffer design and replay mechanism.

## Notes & Warnings

- The outputSeq counter must be protected by task.mu to prevent race conditions during concurrent output and reads
- Sequence numbers are per-task, not global — each Task struct maintains its own counter
- When a task is created, outputSeq starts at 0 (first output increments to 1)
- The ring buffer stores Event structs which now need Seq field — verify existing Event struct initialization
- Sequence numbers should never reset for a task's lifetime — they only increase
- Clients should handle Seq values that jump significantly (gap detection) but not require consecutive numbering
- If a task is stopped and restarted, does it use the same Task struct? If so, outputSeq continues from where it left off. This is correct behavior as the task maintains identity across restarts via task_id and exitHistory tracking.
