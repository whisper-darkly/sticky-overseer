---
title: Implement CEL-based output filtering in handler_exec.go (finish deferred OutputRule)
created: 2026-02-21
origin: Post-audit improvement plan — OutputRule is an empty placeholder struct. The CEL infrastructure for output filtering already exists in actions.go but needs to be wired into the exec handler.
priority: medium
complexity: medium
notes:
  - OutputRule struct is currently empty and unused
  - CEL infrastructure (CompileOutputCELProgram, EvalOutputCELBool, OutputContext) already exists in actions.go
  - Per-line filtering must happen at callback level, not at pipe drain level
  - Both stdout and stderr pipes must always be drained to prevent child process blocking
  - Output filtering enables selective forwarding of command output to clients based on CEL expressions
---

Follow exactly and without stopping:

## Task: Implement CEL-based output filtering in handler_exec.go

## Background & Context

The sticky-overseer project has a partially implemented output filtering system. The CEL (Common Expression Language) infrastructure for evaluating output rules already exists in actions.go with three exported functions:
- CompileOutputCELProgram(expr string) — compiles a CEL expression for output filtering
- EvalOutputCELBool(prog cel.Program, OutputContext) — evaluates the compiled program
- OutputContext struct — holds the context variables available to CEL expressions (stream, data, json)

However, the handler_exec.go file has an empty OutputRule struct{} placeholder that was never connected to this infrastructure. The ExecOutputConfig has Stdout and Stderr fields of type OutputRule, but they are never used during execution. Currently, handler_exec.go unconditionally sets IncludeStdout: true and IncludeStderr: true in the workerConfig, meaning all output is forwarded regardless of any filtering rules.

This work defers that filtering from the initial post-audit review to enable selective output forwarding based on user-defined CEL expressions. This is valuable for tasks that generate verbose output where clients only care about specific lines (e.g., errors, specific JSON fields, or pattern-matched data).

The existing worker.go architecture drains both stdout and stderr to prevent child process blocking. Per-line filtering must happen at the callback level in the onOutput handler, not at the pipe drain level.

## Problem Description

Current state:
- OutputRule is defined as `type OutputRule struct{}` in handler_exec.go — completely empty
- ExecOutputConfig has Output.Stdout and Output.Stderr fields of type OutputRule that are parsed from JSON/YAML but never used
- No CEL program compilation happens for output rules
- Handler_exec.go Start() method unconditionally passes cb.onOutput to startWorker without any filtering
- All output is forwarded to all connected clients regardless of filter rules

Symptoms:
- Clients receive all command output even when they only care about specific lines
- No way to filter verbose output at the server level
- The CEL infrastructure exists but is orphaned and unused

Current workarounds:
- Clients must filter output on their side
- No server-level reduction of message traffic

## Implementation Plan

### Step 1: Define OutputRule struct with CEL program field (handler_exec.go)

Replace the empty `type OutputRule struct{}` with:
```go
// OutputRule controls whether an output line is forwarded to clients.
// Condition is a CEL expression evaluated against the output line context.
// Available variables: output.stream (string), output.data (string), output.json (map).
// Empty Condition means always forward.
type OutputRule struct {
    Condition string     `json:"condition,omitempty"`
    prog      cel.Program // compiled at Create time; nil = always forward
}
```

Location: handler_exec.go, near the ExecOutputConfig struct definition

### Step 2: Compile OutputRule CEL programs at Create time (handler_exec.go)

In the execHandlerFactory.Create() method, after parsing ExecHandlerConfig and before returning the handler, add CEL program compilation:

```go
if cfg.Output.Stdout.Condition != "" {
    prog, err := CompileOutputCELProgram(cfg.Output.Stdout.Condition)
    if err != nil {
        return nil, fmt.Errorf("stdout filter CEL error: %w", err)
    }
    cfg.Output.Stdout.prog = prog
}

if cfg.Output.Stderr.Condition != "" {
    prog, err := CompileOutputCELProgram(cfg.Output.Stderr.Condition)
    if err != nil {
        return nil, fmt.Errorf("stderr filter CEL error: %w", err)
    }
    cfg.Output.Stderr.prog = prog
}
```

This ensures CEL expressions are validated at config creation time, not at runtime during task execution. Compilation errors surface immediately.

### Step 3: Wire output filtering via callback wrapper (handler_exec.go Start())

In the handler's Start() method, before calling startWorker(), create a filtered callback wrapper:

```go
filteredCB := cb
filteredCB.onOutput = func(msg OutputMessage) {
    rule := h.cfg.Output.Stdout
    if msg.Stream == StreamStderr {
        rule = h.cfg.Output.Stderr
    }
    
    // If there's a CEL program, evaluate it
    if rule.prog != nil {
        ctx := OutputContext{
            Stream: string(msg.Stream),
            Data:   msg.Data,
        }
        pass, err := EvalOutputCELBool(rule.prog, ctx)
        if err != nil || !pass {
            return // Drop this line — don't forward to original callback
        }
    }
    
    cb.onOutput(msg) // Forward to original callback if filter passed
}

return startWorker(workerConfig{
    TaskID:        taskID,
    Command:       entrypoint,
    Args:          renderedArgs,
    IncludeStdout: true,  // Always true — draining prevents child blocking
    IncludeStderr: true,  // Always true — draining prevents child blocking
}, filteredCB)
```

Location: handler_exec.go in the Start() method, replacing the current startWorker call.

Critical: Keep IncludeStdout and IncludeStderr both true. Per-line filtering happens at the callback level, not at the pipe drain level. Both pipes must always be drained to prevent the child process from blocking on a full output buffer.

### Step 4: Add documentation to ExecOutputConfig (handler_exec.go)

Add struct field comments with example CEL expressions to ExecOutputConfig and ExecHandlerConfig:

```go
type ExecOutputConfig struct {
    // Stdout filters output lines from the task's stdout stream.
    // Condition is a CEL expression (empty = always forward).
    // Available context: output.stream (string), output.data (string), output.json (map).
    // Example: "output.data.contains('ERROR')" — only forward ERROR lines.
    Stdout OutputRule `json:"stdout,omitempty"`
    
    // Stderr filters output lines from the task's stderr stream.
    // Same CEL expression rules as Stdout.
    Stderr OutputRule `json:"stderr,omitempty"`
}

type ExecHandlerConfig struct {
    // ... other fields ...
    
    // Output defines per-stream output filtering rules.
    // Example YAML:
    //   output:
    //     stdout:
    //       condition: "output.data.contains('ERROR')"
    //     stderr:
    //       condition: ""
    Output ExecOutputConfig `json:"output,omitempty"`
}
```

Location: handler_exec.go struct comments.

### Step 5: Add comprehensive tests (handler_exec_test.go)

Add three new test functions to verify output filtering works correctly:

#### Test 5a: TestExecHandler_OutputFilter_Stdout
```go
func TestExecHandler_OutputFilter_Stdout(t *testing.T) {
    // Create handler with stdout filter: only lines containing "PASS"
    cfg := ExecHandlerConfig{
        Command: "echo",
        Args:    []string{"PASS line\nFAIL line\nPASS another"},
        Output: ExecOutputConfig{
            Stdout: OutputRule{
                Condition: "output.data.contains('PASS')",
            },
        },
    }
    
    factory := &execHandlerFactory{defaultCommand: ""}
    handler, err := factory.Create(cfg)
    // ... assertions for handler creation ...
    
    outputs := []OutputMessage{}
    cb := &TaskCallbacks{
        onOutput: func(msg OutputMessage) {
            outputs = append(outputs, msg)
        },
        // ... other callbacks ...
    }
    
    taskID := uuid.New()
    err = handler.Start(taskID, cb)
    // ... wait for completion ...
    
    // Verify only PASS lines were forwarded
    if len(outputs) != 2 {
        t.Errorf("Expected 2 output lines (PASS only), got %d", len(outputs))
    }
    for _, out := range outputs {
        if !strings.Contains(out.Data, "PASS") {
            t.Errorf("Unexpected output in filtered results: %s", out.Data)
        }
    }
}
```

#### Test 5b: TestExecHandler_OutputFilter_EmptyCondition
```go
func TestExecHandler_OutputFilter_EmptyCondition(t *testing.T) {
    // Create handler with empty output filter (no filtering)
    cfg := ExecHandlerConfig{
        Command: "echo",
        Args:    []string{"line1\nline2\nline3"},
        Output: ExecOutputConfig{
            Stdout: OutputRule{
                Condition: "", // Empty = always forward
            },
        },
    }
    
    factory := &execHandlerFactory{defaultCommand: ""}
    handler, err := factory.Create(cfg)
    // ... assertions ...
    
    outputs := []OutputMessage{}
    cb := &TaskCallbacks{
        onOutput: func(msg OutputMessage) {
            outputs = append(outputs, msg)
        },
        // ... other callbacks ...
    }
    
    taskID := uuid.New()
    err = handler.Start(taskID, cb)
    // ... wait for completion ...
    
    // Verify all lines were forwarded (no filtering)
    if len(outputs) != 3 {
        t.Errorf("Expected 3 output lines (no filter), got %d", len(outputs))
    }
}
```

#### Test 5c: TestExecHandler_OutputFilter_BadCEL
```go
func TestExecHandler_OutputFilter_BadCEL(t *testing.T) {
    // Create handler with invalid CEL expression — should fail at Create time
    cfg := ExecHandlerConfig{
        Command: "echo",
        Args:    []string{"test"},
        Output: ExecOutputConfig{
            Stdout: OutputRule{
                Condition: "output.data.invalid()", // Invalid CEL syntax
            },
        },
    }
    
    factory := &execHandlerFactory{defaultCommand: ""}
    handler, err := factory.Create(cfg)
    
    // Verify error occurred at Create time, not at Start time
    if err == nil {
        t.Error("Expected CEL compilation error, got nil")
    }
    if !strings.Contains(err.Error(), "CEL error") {
        t.Errorf("Expected CEL error message, got: %v", err)
    }
}
```

Tests verify:
- Output filtering works and only forwards matching lines
- Empty condition (no filtering) forwards all lines
- Invalid CEL expressions are caught at Create time and produce clear error messages
- Different filters on stdout and stderr are independent

### Step 6: Verify imports and dependencies

Ensure handler_exec.go has all necessary imports:
- `github.com/google/cel-go/cel` — for CEL type definitions (may already be imported transitively through actions.go)
- Standard Go packages: `fmt`, `strings`

Check that actions.go exports are accessible:
- CompileOutputCELProgram(string) (cel.Program, error)
- EvalOutputCELBool(cel.Program, OutputContext) (bool, error)
- OutputContext struct definition

## Technical Requirements

**Files to modify:**
- handler_exec.go — main implementation (OutputRule struct, Create(), Start())
- handler_exec_test.go — add three test functions
- actions.go — verify exports are correct (may require no changes)

**Dependencies:**
- github.com/google/cel-go/cel — CEL program type and evaluation (already in project)
- Standard Go: fmt, strings, uuid (already imported in handler_exec.go)

**Commands to verify:**
```bash
cd /home/mmulligan/Development/whisper-darkly-github/sticky-overseer

# Compile to verify syntax
go build ./...

# Run all tests including new ones
go test -race ./... -v

# Static analysis
go vet ./...

# Specific test execution
go test -run TestExecHandler_OutputFilter ./...
```

**Reference implementations:**
- actions.go CompileOutputCELProgram() — shows how CEL programs are compiled and cached
- actions.go EvalOutputCELBool() — shows how to evaluate CEL programs with context
- worker.go onOutput callback handling — shows current callback architecture
- handler_exec.go Start() method — shows where to insert filtering wrapper

## Success Criteria

1. OutputRule struct has Condition field (string) and prog field (cel.Program)
2. OutputRule CEL programs are compiled in execHandlerFactory.Create() with proper error handling
3. Output filtering wrapper is implemented in handler_exec.go Start() method
4. Per-line filtering drops lines that don't match the CEL condition
5. Empty conditions (or nil prog) forward all lines without filtering
6. Both stdout and stderr pipes are always drained (IncludeStdout: true, IncludeStderr: true)
7. Three new tests pass: filtering, no-filter, and bad-CEL tests
8. `go test -race ./...` passes with no race conditions or test failures
9. `go vet ./...` produces no new warnings
10. Build succeeds: `go build ./...`

## Expected Outcome

When complete, sticky-overseer's exec handler will support output filtering. Users can define CEL expressions in their exec handler configuration to selectively forward output lines to clients. For example:

```yaml
handlers:
  - type: exec
    name: production-logs
    command: /usr/bin/tail
    args: ["-f", "/var/log/app.log"]
    output:
      stdout:
        condition: "output.data.contains('ERROR') || output.data.contains('WARN')"
```

This configuration would only forward log lines containing ERROR or WARN to connected clients, reducing message traffic and allowing server-side filtering of verbose output.

## Reference Information

**Files involved:**
- /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/handler_exec.go — main implementation file
- /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/handler_exec_test.go — test file
- /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/actions.go — existing CEL infrastructure
- /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/worker.go — callback architecture reference
- /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/messages.go — OutputMessage struct definition

**Related code to reference:**
- CompileOutputCELProgram function in actions.go
- EvalOutputCELBool function in actions.go
- OutputContext struct in actions.go
- TaskCallbacks struct definition
- StreamStdout/StreamStderr constants

**CEL expression examples:**
- `output.data.contains('ERROR')` — lines containing ERROR
- `output.data.startsWith('WARN')` — lines starting with WARN
- `output.stream == 'stderr'` — only stderr output
- `output.data.length > 100` — only long lines
- `!output.data.contains('DEBUG')` — exclude DEBUG lines

## Notes & Warnings

- **Critical**: Both IncludeStdout and IncludeStderr must remain true in the workerConfig. The per-line filtering happens at the callback level. If either pipe is not drained, the child process will block when its output buffer fills.

- **CEL evaluation happens synchronously**: Each output line is evaluated immediately in the onOutput callback. Ensure CEL expressions are simple and fast-executing. Complex expressions will impact per-line throughput.

- **Error handling**: If EvalOutputCELBool returns an error (e.g., type mismatch in CEL expression), the line is dropped and logged. This prevents malformed filters from crashing the handler.

- **Empty OutputRule**: An OutputRule with an empty Condition string or a nil prog field means "always forward" — no filtering is applied.

- **Testing considerations**: Test commands should produce deterministic multi-line output. Use `echo -e` with newlines or simple shell commands that produce predictable output.

- **Backward compatibility**: Handlers without output filters defined will have empty OutputRule structs with nil prog fields, which means all output is forwarded (no filtering). This preserves existing behavior.

- **CEL context variables**: OutputContext provides stream (string), data (string), and json (map) to CEL expressions. Ensure test expressions only use documented context fields.
