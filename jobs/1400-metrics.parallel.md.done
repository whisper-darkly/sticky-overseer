---
title: "Implement in-memory metrics system"
created: 2026-02-21
origin: Post-audit improvement plan (job 1400)
priority: medium
complexity: medium
notes:
  - Metrics are in-memory only, reset on restart
  - Query by global / per-action / per-task via WebSocket message type "metrics"
  - Depends on jobs 1350 (hub cleanup), 1380 (subscriptions), 1330 (seq numbers)
  - New file metrics.go; wire into hub.go and messages.go
---

## Goal

Add an in-memory metrics system to sticky-overseer. Metrics are queryable via a new
`{"type":"metrics"}` WebSocket message at three granularities: global, per-action, per-task.
All counters are reset on process restart.

## New file: metrics.go

Create `/home/mmulligan/Development/whisper-darkly-github/sticky-overseer/metrics.go`
(package main).

### Structs

```go
// TaskMetrics holds lifetime stats for a single task.
type TaskMetrics struct {
    OutputLines  int64
    RestartCount int64
    RuntimeMs    int64
    LastExitCode int
}

// ActionMetrics holds aggregate stats for all tasks of one action type.
type ActionMetrics struct {
    TasksStarted    int64
    TasksCompleted  int64
    TasksErrored    int64
    TasksRestarted  int64
    TotalOutputLines int64
}

// Metrics is the central registry. All fields are protected by mu except the
// atomic global counters which use sync/atomic.
type Metrics struct {
    mu sync.RWMutex

    // Global counters (use sync/atomic for hot-path writes)
    tasksStarted    atomic.Int64
    tasksCompleted  atomic.Int64
    tasksErrored    atomic.Int64
    tasksRestarted  atomic.Int64
    totalOutputLines atomic.Int64

    // Queue counters
    enqueued   atomic.Int64
    dequeued   atomic.Int64
    displaced  atomic.Int64
    expired    atomic.Int64

    // Per-action (keyed by action name)
    byAction map[string]*ActionMetrics

    // Per-task (keyed by task_id; cap at 10000 entries, evict oldest)
    byTask   map[string]*TaskMetrics
    taskOrder []string // insertion order for eviction
}

func NewMetrics() *Metrics {
    return &Metrics{
        byAction: make(map[string]*ActionMetrics),
        byTask:   make(map[string]*TaskMetrics),
    }
}
```

### Methods

```go
// RecordStart increments global + per-action started counters.
// Also initialises per-task entry (evicting oldest if cap 10000 exceeded).
func (m *Metrics) RecordStart(taskID, action string)

// RecordExit updates completed/errored counters, runtime, last exit code.
func (m *Metrics) RecordExit(taskID, action string, exitCode int, errored bool, runtimeMs int64)

// RecordRestart increments global + per-action + per-task restart counters.
func (m *Metrics) RecordRestart(taskID, action string)

// RecordOutput increments global + per-action + per-task output line counters.
func (m *Metrics) RecordOutput(taskID, action string)

// RecordEnqueued / RecordDequeued / RecordDisplaced / RecordExpired — queue counters.
func (m *Metrics) RecordEnqueued()
func (m *Metrics) RecordDequeued()
func (m *Metrics) RecordDisplaced()
func (m *Metrics) RecordExpired()

// GlobalSnapshot returns a copy of the global counters.
func (m *Metrics) GlobalSnapshot() GlobalMetricsSnapshot

// ActionSnapshot returns a copy of per-action counters (nil if unknown).
func (m *Metrics) ActionSnapshot(action string) *ActionMetrics

// TaskSnapshot returns a copy of per-task counters (nil if unknown).
func (m *Metrics) TaskSnapshot(taskID string) *TaskMetrics
```

Use `sync.RWMutex` for byAction and byTask maps; use `atomic.Int64` for the global
counters so RecordOutput (called per line) is fast.

## messages.go changes

Add `MetricsMessage` response type:

```go
type GlobalMetricsSnapshot struct {
    TasksStarted     int64 `json:"tasks_started"`
    TasksCompleted   int64 `json:"tasks_completed"`
    TasksErrored     int64 `json:"tasks_errored"`
    TasksRestarted   int64 `json:"tasks_restarted"`
    TotalOutputLines int64 `json:"total_output_lines"`
    Enqueued         int64 `json:"enqueued"`
    Dequeued         int64 `json:"dequeued"`
    Displaced        int64 `json:"displaced"`
    Expired          int64 `json:"expired"`
}

type MetricsMessage struct {
    Type    string                 `json:"type"`    // "metrics"
    ID      string                 `json:"id,omitempty"`
    Global  *GlobalMetricsSnapshot `json:"global,omitempty"`
    Action  *ActionMetrics         `json:"action,omitempty"`
    Task    *TaskMetrics           `json:"task,omitempty"`
}
```

Also add `"metrics"` to the dispatch switch in `IncomingMessage` handling.

## hub.go changes

1. Add `metrics *Metrics` field to `Hub` struct.
2. Initialise in `newHub`: `h.metrics = NewMetrics()`.
3. Wire recording at each event:
   - `handleStart` success → `h.metrics.RecordStart(taskID, action)`
   - `onWorkerExited` → `h.metrics.RecordExit(...)` (compute runtimeMs from worker start time)
   - restart scheduling → `h.metrics.RecordRestart(...)`
   - `onOutput` callback → `h.metrics.RecordOutput(taskID, action)`
   - pool events (Enqueued/Dequeued/Displaced/Expired) → wire through `workerCallbacks` or
     pool callbacks if available; alternatively record from handleStart queueing path and pool
     sweep callbacks.
4. Add `handleMetrics(conn Conn, msg IncomingMessage)`:
   ```go
   func (h *Hub) handleMetrics(conn Conn, msg IncomingMessage) {
       resp := MetricsMessage{Type: "metrics", ID: msg.ID}
       switch {
       case msg.TaskID != "":
           resp.Task = h.metrics.TaskSnapshot(msg.TaskID)
       case msg.Action != "":
           resp.Action = h.metrics.ActionSnapshot(msg.Action)
       default:
           g := h.metrics.GlobalSnapshot()
           resp.Global = &g
       }
       conn.WriteJSON(resp)
   }
   ```
5. Dispatch `"metrics"` in `HandleClient` switch.

## Success criteria

- `go build ./...` passes
- New `metrics_test.go` covers: RecordStart/RecordExit/RecordRestart/RecordOutput counters,
  GlobalSnapshot values, ActionSnapshot values, TaskSnapshot values, per-task eviction at cap,
  concurrent writes under `-race`
- `go test -race ./...` passes
- Querying `{"type":"metrics"}` returns global stats; `{"type":"metrics","action":"echo"}`
  returns action-level stats; `{"type":"metrics","task_id":"<id>"}` returns task-level stats
