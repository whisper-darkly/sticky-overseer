---
title: Formalize WS Manifest schema and commit to sticky-bb
created: 2026-02-21
origin: sticky-bb needs a machine-readable protocol descriptor so it can auto-generate WebSocket command forms for any overseer-compatible backend
priority: high
complexity: medium
notes:
  - Work in the sticky-bb repo at ../sticky-bb (sibling directory)
  - This job creates the schema spec — job 1510 implements the actual endpoint
  - The schema must be generic enough to describe any WS protocol, not just sticky-overseer
  - The example manifest should accurately reflect the full sticky-overseer protocol
  - Commit all files to sticky-bb git before marking done
---

Follow exactly and without stopping:

## Task: Design, document, and commit the WS Manifest schema to sticky-bb

The WS Manifest format is a JSON document that fully describes a WebSocket-based
message protocol so that a generic UI (like sticky-bb) can auto-generate send forms,
correlation-aware response panels, and live event streams without any hardcoded
knowledge of the underlying protocol.

---

## Step 1: Create `docs/` directory in sticky-bb and write the specification

File: `../sticky-bb/docs/ws-manifest-spec.md`

Write the full specification document with the following content (write it
verbatim — this is the canonical spec):

```markdown
# WS Manifest Specification

Version: 1.0
Status: Draft

## Overview

A **WS Manifest** is a JSON document served by a WebSocket-capable HTTP server
that describes every message the server can send and receive, how those messages
relate to each other, and what data types they carry. The purpose is to allow
generic tooling (e.g. sticky-bb) to automatically build:

- Typed input forms for every sendable message
- Correlated response panels that match replies to requests
- Live broadcast panels that render unsolicited server events
- Action-specific parameter forms when the protocol supports dynamic capabilities

The manifest format is protocol-agnostic. The sticky-overseer example is the
reference implementation.

---

## Document Structure

```json
{
  "$schema": "...",
  "protocol":    "string — short machine name (e.g. \"sticky-overseer\")",
  "version":     "string — semver of the running server instance",
  "description": "string — human-readable description of the protocol",
  "transport": { ... },
  "types":       { "<name>": TypeDef, ... },
  "messages":    { "<type-string>": MessageDef, ... },
  "operations":  { "<name>": OperationDef, ... },
  "actions":     [ ActionInfo, ... ]
}
```

---

## `transport`

Describes the WebSocket connection and message envelope conventions.

| Field               | Type   | Required | Description |
|---------------------|--------|----------|-------------|
| `path`              | string | yes      | HTTP path of the WebSocket endpoint (e.g. `"/ws"`) |
| `type_field`        | string | yes      | Name of the field in every message that contains the message type discriminant |
| `correlation_field` | string | no       | Name of the optional client-set field echoed in direct server responses; omit if the protocol has no correlation |

---

## `types`

A map of reusable named type definitions. All names are PascalCase. Referenced
elsewhere with `{ "$ref": "#/types/<Name>" }`.

### TypeDef

```json
{
  "type":        "string — one of: string, integer, boolean, timestamp, duration, uuid, enum, object, array, map",
  "description": "string — optional human-readable description",
  "values":      ["array of string — allowed values, required when type=enum"],
  "fields":      { "<key>": FieldDef, ... },
  "items":       "TypeDef or $ref — element type, required when type=array",
  "value_type":  "TypeDef or $ref — value type, required when type=map (keys are always string)"
}
```

#### Primitive types

| type        | JSON representation             | Notes |
|-------------|---------------------------------|-------|
| `string`    | JSON string                     | |
| `integer`   | JSON number (no fraction)       | |
| `boolean`   | JSON boolean                    | |
| `timestamp` | JSON string, RFC3339 UTC        | e.g. `"2026-01-01T12:00:00Z"` |
| `duration`  | JSON string, Go duration format | e.g. `"30s"`, `"1m30s"`, `"2h"` |
| `uuid`      | JSON string, UUID v4 format     | e.g. `"550e8400-e29b-41d4-a716-446655440000"` |
| `enum`      | JSON string                     | Allowed values listed in `values` array |

#### Composite types

- `object` — requires `fields` map
- `array` — requires `items` (TypeDef or `$ref`)
- `map` — requires `value_type` (TypeDef or `$ref`); keys are always strings

---

## `messages`

A map from the message's `type` string value to its definition. This is the
authoritative list of all messages in the protocol.

### MessageDef

```json
{
  "description": "string — required, human-readable explanation",
  "direction":   "\"c2s\" | \"s2c\"",
  "delivery":    "\"direct\" | \"broadcast\" | \"broadcast_subscribers\" — s2c only",
  "fields":      { "<json-key>": FieldDef, ... }
}
```

#### Directions

- `c2s` — client-to-server: messages the client sends
- `s2c` — server-to-client: messages the server sends

#### Delivery (s2c only)

| value                    | Meaning |
|--------------------------|---------|
| `direct`                 | Sent only to the requesting connection; typically correlated by `correlation_field` |
| `broadcast`              | Sent to every connected client |
| `broadcast_subscribers`  | Sent only to connections that have subscribed to the relevant resource |

### FieldDef

A FieldDef extends TypeDef with additional metadata for UI rendering and
validation:

```json
{
  "type":        "string — same type values as TypeDef",
  "$ref":        "string — reference to a named type, e.g. \"#/types/RetryPolicy\"",
  "description": "string — optional, for tooltips/labels",
  "required":    "boolean — default false; if true the field must be present",
  "default":     "any — default value in its native JSON type",
  "ui_hint":     "\"hidden\" | \"textarea\" | \"json-editor\" | \"password\" — optional rendering hint",
  "values":      ["array of string — when type=enum"],
  "fields":      { ... },
  "items":       { ... },
  "value_type":  { ... }
}
```

Fields with `ui_hint: "hidden"` should be pre-filled by the UI (e.g. the `type`
field on every outgoing message).

---

## `operations`

Named logical operations that pair a client send with expected server responses.
This is the primary structure a UI uses to build request/response panels.

### OperationDef

```json
{
  "description": "string — required",
  "send":        "string — message type (must be a c2s message)",
  "responses": {
    "direct": {
      "success": ["array of s2c message type strings"],
      "error":   ["array of s2c message type strings"]
    },
    "side_effects": {
      "broadcast":              ["array of s2c message type strings"],
      "broadcast_subscribers":  ["array of s2c message type strings"]
    }
  },
  "notes": "string — optional prose clarifications, edge cases, etc."
}
```

`responses.direct` messages are correlated by `correlation_field`. UI should
display them in a response panel tied to the specific request.

`responses.side_effects` may arrive at any time after the request and are not
correlated. UI should display them in a live event stream.

---

## `actions`

A runtime-populated array of `ActionInfo` objects describing the dynamic
capabilities of the server (equivalent to the protocol's `describe` response).
This field is present only when the protocol supports dynamic actions.

### ActionInfo

```json
{
  "name":        "string — action key (e.g. \"build\")",
  "type":        "string — driver/factory type (e.g. \"exec\")",
  "description": "string — optional, human-readable",
  "params":      { "<param-name>": ParamSpec, ... },
  "task_pool":   { ... },
  "retry":       { ... },
  "dedupe_key":  ["array of param names"]
}
```

### ParamSpec

```json
{
  "default":  "string | null — null means the parameter is required",
  "validate": "string — optional CEL expression operating on 'value' (string)"
}
```

A `null` default means the parameter is required. Any other value means optional
with that default.

---

## Conventions

1. **Type discriminant**: Every message (both directions) must have a field
   named by `transport.type_field` whose value matches the key in `messages`.

2. **Correlation**: If `transport.correlation_field` is set, clients may include
   it in any c2s message. Servers echo it in the corresponding direct response.
   Broadcast messages never carry the correlation field.

3. **Error responses**: An `error` s2c message type (delivery: `direct`) is
   used for protocol-level errors. It always carries the correlation field when
   responding to a correlated request.

4. **Auto-subscription**: Some operations automatically subscribe the sending
   connection to future broadcasts for a new resource. This is noted in the
   operation's `notes` field.

5. **Mutual exclusion**: Some request fields are mutually exclusive (e.g.
   `action` vs `task_id` on `metrics`). Document this in the operation's
   `notes` field; the manifest format does not model exclusion constraints.
```

---

## Step 2: Write the JSON meta-schema

File: `../sticky-bb/docs/ws-manifest.schema.json`

This JSON Schema validates a WS Manifest document:

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "ws-manifest.schema.json",
  "title": "WS Manifest",
  "description": "Machine-readable descriptor for a WebSocket message protocol",
  "type": "object",
  "required": ["protocol", "version", "description", "transport", "messages", "operations"],
  "additionalProperties": false,
  "properties": {
    "$schema":     { "type": "string" },
    "protocol":    { "type": "string" },
    "version":     { "type": "string" },
    "description": { "type": "string" },
    "transport": {
      "type": "object",
      "required": ["path", "type_field"],
      "additionalProperties": false,
      "properties": {
        "path":              { "type": "string" },
        "type_field":        { "type": "string" },
        "correlation_field": { "type": "string" }
      }
    },
    "types": {
      "type": "object",
      "additionalProperties": { "$ref": "#/$defs/TypeDef" }
    },
    "messages": {
      "type": "object",
      "additionalProperties": { "$ref": "#/$defs/MessageDef" }
    },
    "operations": {
      "type": "object",
      "additionalProperties": { "$ref": "#/$defs/OperationDef" }
    },
    "actions": {
      "type": "array",
      "items": { "$ref": "#/$defs/ActionInfo" }
    }
  },
  "$defs": {
    "TypeDef": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "enum": ["string","integer","boolean","timestamp","duration","uuid","enum","object","array","map"]
        },
        "description": { "type": "string" },
        "values":      { "type": "array", "items": { "type": "string" } },
        "fields":      { "type": "object", "additionalProperties": { "$ref": "#/$defs/FieldDef" } },
        "items":       { "oneOf": [{ "$ref": "#/$defs/TypeDef" }, { "$ref": "#/$defs/Ref" }] },
        "value_type":  { "oneOf": [{ "$ref": "#/$defs/TypeDef" }, { "$ref": "#/$defs/Ref" }] }
      }
    },
    "FieldDef": {
      "type": "object",
      "properties": {
        "type":        { "type": "string" },
        "$ref":        { "type": "string" },
        "description": { "type": "string" },
        "required":    { "type": "boolean" },
        "default":     {},
        "ui_hint":     { "type": "string", "enum": ["hidden","textarea","json-editor","password"] },
        "values":      { "type": "array", "items": { "type": "string" } },
        "fields":      { "type": "object", "additionalProperties": { "$ref": "#/$defs/FieldDef" } },
        "items":       { "oneOf": [{ "$ref": "#/$defs/TypeDef" }, { "$ref": "#/$defs/Ref" }] },
        "value_type":  { "oneOf": [{ "$ref": "#/$defs/TypeDef" }, { "$ref": "#/$defs/Ref" }] }
      }
    },
    "Ref": {
      "type": "object",
      "required": ["$ref"],
      "properties": { "$ref": { "type": "string" } }
    },
    "MessageDef": {
      "type": "object",
      "required": ["description", "direction", "fields"],
      "additionalProperties": false,
      "properties": {
        "description": { "type": "string" },
        "direction":   { "type": "string", "enum": ["c2s","s2c"] },
        "delivery":    { "type": "string", "enum": ["direct","broadcast","broadcast_subscribers"] },
        "fields":      { "type": "object", "additionalProperties": { "$ref": "#/$defs/FieldDef" } }
      }
    },
    "OperationDef": {
      "type": "object",
      "required": ["description", "send", "responses"],
      "additionalProperties": false,
      "properties": {
        "description": { "type": "string" },
        "send":        { "type": "string" },
        "responses": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "direct": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "success": { "type": "array", "items": { "type": "string" } },
                "error":   { "type": "array", "items": { "type": "string" } }
              }
            },
            "side_effects": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "broadcast":             { "type": "array", "items": { "type": "string" } },
                "broadcast_subscribers": { "type": "array", "items": { "type": "string" } }
              }
            }
          }
        },
        "notes": { "type": "string" }
      }
    },
    "ActionInfo": {
      "type": "object",
      "required": ["name"],
      "properties": {
        "name":        { "type": "string" },
        "type":        { "type": "string" },
        "description": { "type": "string" },
        "params": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "properties": {
              "default":  {},
              "validate": { "type": "string" }
            }
          }
        },
        "task_pool":  { "type": "object" },
        "retry":      { "type": "object" },
        "dedupe_key": { "type": "array", "items": { "type": "string" } }
      }
    }
  }
}
```

---

## Step 3: Write the sticky-overseer example manifest

File: `../sticky-bb/docs/ws-manifest-overseer-example.json`

This is a complete, accurate WS Manifest for the sticky-overseer protocol. Write
it from scratch using the definitions in `messages.go`, `actions.go`, `pool.go`,
`metrics.go`, and `hub.go` from the sticky-overseer repo at `../sticky-overseer`.

The manifest must include:

### transport

```json
{
  "path": "/ws",
  "type_field": "type",
  "correlation_field": "id"
}
```

### types

Define the following reusable types (all object types unless noted):

- **TaskState** (enum): `"active"`, `"stopped"`, `"errored"`, `"queued"`
- **WorkerState** (enum): `"running"`, `"exited"`
- **Stream** (enum): `"stdout"`, `"stderr"`
- **QueueOrder** (enum): `"first"` (FIFO), `"last"` (LIFO)
- **ExcessAction** (enum): `"stop"`, `"requeue"`
- **KillOrder** (enum): `"first"` (longest-running first), `"last"` (shortest-running first)
- **RetryPolicy** (object): `restart_delay` (duration, optional), `error_window` (duration, optional), `error_threshold` (integer, optional)
- **QueueConfig** (object): `enabled` (boolean), `size` (integer), `order` ($ref QueueOrder), `max_age` (integer, seconds, 0=no expiry), `displace` (object: `enabled` boolean, `order` $ref KillOrder)
- **ExcessConfig** (object): `action` ($ref ExcessAction), `order` ($ref KillOrder), `grace` (integer, seconds before SIGKILL)
- **PoolConfig** (object): `limit` (integer), `queue` ($ref QueueConfig, optional), `excess` ($ref ExcessConfig, optional)
- **PoolInfo** (object): `limit` (integer), `running` (integer), `queue_depth` (integer), `queue_items` (array of objects with `task_id` string and `action` string)
- **ParamSpec** (object): `default` (string, nullable — null means required), `validate` (string, CEL expression, optional)
- **ActionInfo** (object): `name` (string), `type` (string), `description` (string, optional), `params` (map of string→$ref ParamSpec, optional), `task_pool` ($ref PoolConfig), `retry` ($ref RetryPolicy, optional), `dedupe_key` (array of string, optional)
- **TaskInfo** (object): all fields from the `TaskInfo` struct in `messages.go`
- **TaskMetrics** (object): `output_lines`, `restart_count`, `runtime_ms` (all integer), `last_exit_code` (integer)
- **ActionMetrics** (object): `tasks_started`, `tasks_completed`, `tasks_errored`, `tasks_restarted`, `total_output_lines` (all integer)
- **GlobalMetrics** (object): `tasks_started`, `tasks_completed`, `tasks_errored`, `tasks_restarted`, `total_output_lines`, `enqueued`, `dequeued`, `displaced`, `expired` (all integer)

### messages — client-to-server (c2s)

Define all 12 client message types. Each has a `type` field (string, required,
hidden, const equal to the message type key). Only include fields that are
actually used by each handler (check hub.go carefully).

| type         | key fields (beyond `type` and `id`) |
|--------------|--------------------------------------|
| `start`      | `action` (string, required), `task_id` (uuid, optional — server generates if omitted), `params` (map string→string, optional), `force` (boolean, optional, default false), `retry_policy` ($ref RetryPolicy, optional) |
| `stop`       | `task_id` (uuid, required) |
| `reset`      | `task_id` (uuid, required) — restarts an errored task |
| `list`       | `since` (timestamp, optional — only return tasks active since this time) |
| `replay`     | `task_id` (uuid, required), `since` (timestamp, optional — replay only output after this time) |
| `describe`   | `action` (string, optional — describe one action; omit for all) |
| `pool_info`  | `action` (string, optional — info for one action; omit for global) |
| `purge`      | `action` (string, optional — purge queue for one action; omit for all) |
| `set_pool`   | `action` (string, optional), `limit` (integer, optional), `queue_size` (integer, optional), `excess` ($ref ExcessConfig, optional) |
| `subscribe`  | `task_id` (uuid, required) |
| `unsubscribe`| `task_id` (uuid, required) |
| `metrics`    | `action` (string, optional), `task_id` (uuid, optional) — mutually exclusive; omit both for global |
| `manifest`   | (no extra fields) — returns the full WS manifest document |

All c2s messages have `id` as an optional string field (the correlation key).

### messages — server-to-client (s2c)

| type            | delivery                | key fields |
|-----------------|-------------------------|------------|
| `started`       | broadcast_subscribers   | `task_id`, `pid` (integer), `restart_of` (integer, 0 if not a restart), `ts` (timestamp) |
| `tasks`         | direct                  | `tasks` (array of $ref TaskInfo) |
| `output`        | broadcast_subscribers   | `task_id`, `pid` (integer), `stream` ($ref Stream), `data` (string), `ts` (timestamp), `seq` (integer, monotonic per-task sequence number) |
| `exited`        | broadcast_subscribers   | `task_id`, `pid` (integer), `exit_code` (integer), `intentional` (boolean), `ts` (timestamp) |
| `restarting`    | broadcast_subscribers   | `task_id`, `pid` (integer), `restart_delay` (duration), `attempt` (integer), `ts` (timestamp) |
| `errored`       | broadcast_subscribers   | `task_id`, `pid` (integer), `exit_count` (integer), `ts` (timestamp) |
| `error`         | direct                  | `message` (string), `existing_task_id` (string, optional — set on duplicate task detection) |
| `queued`        | broadcast               | `task_id`, `action` (string), `position` (integer), `ts` (timestamp) |
| `dequeued`      | broadcast               | `task_id`, `reason` (string), `ts` (timestamp) |
| `actions`       | direct                  | `actions` (array of $ref ActionInfo) |
| `pool_info`     | direct                  | `action` (string, optional), `pool` ($ref PoolInfo) |
| `purged`        | direct                  | `action` (string, optional), `count` (integer) |
| `pool_updated`  | broadcast               | `action` (string, optional), `pool` ($ref PoolInfo) |
| `metrics`       | direct                  | `global` ($ref GlobalMetrics, optional), `action` ($ref ActionMetrics, optional), `task` ($ref TaskMetrics, optional) |
| `subscribed`    | direct                  | `task_id` |
| `unsubscribed`  | direct                  | `task_id` |
| `manifest`      | direct                  | (all fields of the manifest document — same structure as GET /ws/manifest) |

For `started`, `output`, `exited`, `restarting`, `errored`: the submitting
connection is automatically subscribed to the task (happens on `start`), so it
will receive these broadcasts without a separate `subscribe` call.

### operations

Define one operation per client message type. Each operation links the `send`
message to its expected `responses`. Key operations:

- **start_task**: send=`start`
  - direct.success: `["queued", "started"]` (one of these)
  - direct.error: `["error"]`
  - side_effects.broadcast: `["queued", "dequeued", "pool_updated"]`
  - side_effects.broadcast_subscribers: `["started", "output", "exited", "restarting", "errored"]`
  - notes: "The submitting connection is automatically subscribed to the new task. If the pool is at capacity and queuing is enabled, `queued` is broadcast (not `started`). `started` arrives when the task actually launches (may be immediate or after dequeue). `dequeued` arrives if the task is removed from the queue before starting."

- **stop_task**: send=`stop`
  - direct.error: `["error"]`
  - side_effects.broadcast: `["dequeued"]` (if task was queued)
  - side_effects.broadcast_subscribers: `["exited"]` (if task was running)
  - notes: "No direct success message is sent for stop. Confirmation comes via the `exited` broadcast (intentional=true) or `dequeued` broadcast."

- **reset_task**: send=`reset`
  - direct.success: `["started"]`
  - direct.error: `["error"]`
  - notes: "Only works on tasks in the `errored` state. Bypasses pool limits."

- **list_tasks**: send=`list`
  - direct.success: `["tasks"]`
  - direct.error: `["error"]`

- **replay_task**: send=`replay`
  - direct.success: `["output"]` (zero or more output messages, then stops)
  - direct.error: `["error"]`
  - notes: "Replays buffered output from the task's ring buffer directly to the requesting connection. Messages are `output` type but delivered directly, not broadcast."

- **describe_actions**: send=`describe`
  - direct.success: `["actions"]`
  - direct.error: `["error"]`

- **get_pool_info**: send=`pool_info`
  - direct.success: `["pool_info"]`

- **purge_queue**: send=`purge`
  - direct.success: `["purged"]`
  - side_effects.broadcast: `["dequeued"]` (one per purged task)

- **set_pool_limits**: send=`set_pool`
  - direct.success: `["pool_info"]`
  - direct.error: `["error"]`
  - side_effects.broadcast: `["pool_updated"]`

- **subscribe_task**: send=`subscribe`
  - direct.success: `["subscribed"]`
  - direct.error: `["error"]`

- **unsubscribe_task**: send=`unsubscribe`
  - direct.success: `["unsubscribed"]`
  - direct.error: `["error"]`

- **get_metrics**: send=`metrics`
  - direct.success: `["metrics"]`
  - notes: "Exactly one of `global`, `action`, or `task` will be non-null in the response, depending on which optional request fields were set. task_id and action are mutually exclusive; omit both for global metrics."

- **get_manifest**: send=`manifest`
  - direct.success: `["manifest"]`

### actions

Set `"actions": []` in the example (it is populated at runtime by the server).

---

## Step 4: Commit to sticky-bb

In the `../sticky-bb` directory:

```bash
git add docs/
git commit -m "docs: add WS Manifest schema specification and sticky-overseer example

Introduces the WS Manifest format — a machine-readable protocol descriptor
for WebSocket APIs. Enables sticky-bb to auto-generate send forms, response
panels, and live event streams without hardcoded protocol knowledge.

Files added:
- docs/ws-manifest-spec.md      : formal specification (v1.0)
- docs/ws-manifest.schema.json  : JSON Schema meta-schema for validation
- docs/ws-manifest-overseer-example.json : full example for sticky-overseer"
```

---

## Verification

After committing, confirm:

1. `git log --oneline -1` in sticky-bb shows the commit
2. All three files exist under `docs/`
3. The example JSON is valid JSON (run `python3 -m json.tool docs/ws-manifest-overseer-example.json`)
4. The example passes basic sanity: every operation's `send` value exists as a key in `messages`, every `$ref` points to a key in `types`
