---
title: Add per-task subscription model — subscribe/unsubscribe messages, auto-subscribe on start
created: 2026-02-21
origin: Post-audit architecture review — Hub currently broadcasts all task output to every connected client, causing unnecessary network traffic and noise in multi-task deployments. Clients should be able to opt into specific tasks via subscribe/unsubscribe messages, and submitters should auto-subscribe to tasks they start.
priority: high
complexity: medium
notes:
  - Prerequisites: Jobs 1350 (hub-cleanup-db-removal) and 1330 (sequence numbers) must be complete
  - Hub.clients is currently map[Conn]struct{} with no per-connection state
  - New subscription tracking will be added as map[Conn]map[string]struct{} directly in Hub
  - Avoids changing the Conn interface (transport.go)
  - Must distinguish between global events (list, describe, error responses) and task-specific events
---

Follow exactly and without stopping:

## Task: Implement Per-Task Subscription Model

## Background & Context

The sticky-overseer Hub currently implements a broadcast-all pattern where every task's output is sent to every connected WebSocket client. In deployments with multiple concurrent tasks, this creates unnecessary traffic and noise for clients that only care about specific tasks. 

The architecture review identified that a subscription model would better serve multi-task deployments while maintaining backward compatibility for single-task use cases. When a client submits a "start" command, they should automatically subscribe to that task's output. Clients should also have explicit "subscribe" and "unsubscribe" message types to opt into specific tasks.

The Conn interface (defined in transport.go) already provides WriteLock() *sync.Mutex but contains no subscription state. Rather than modifying the Conn interface (which would complicate transport implementations), subscriptions will be tracked in the Hub itself as a map of connections to their subscribed task IDs, protected by the existing Hub.mu RWMutex.

## Problem Description

Current implementation issues:
- Hub.Broadcast sends every event from every task to every connected client
- In deployments with 5+ concurrent tasks, each client receives 80% irrelevant traffic
- No way for clients to filter which tasks they monitor
- No auto-subscription on task start means clients must manually subscribe after starting
- Clients reconnecting and replaying events get all task history, not just their subscribed tasks

## Implementation Plan

### Task 1: Modify Hub struct to track subscriptions (hub.go)

Add field to Hub struct:
```go
subscriptions map[Conn]map[string]struct{} // conn → set of subscribed task_ids; protected by h.mu
```

Update newHub() initialization:
```go
subscriptions: make(map[Conn]map[string]struct{}),
```

### Task 2: Initialize subscriptions for new connections (hub.go HandleClient)

In HandleClient, after accepting the WebSocket connection and before the message loop, initialize subscription state:
```go
h.mu.Lock()
h.subscriptions[conn] = make(map[string]struct{})
h.mu.Unlock()
```

### Task 3: Clean up subscriptions on disconnect (hub.go HandleClient)

In HandleClient cleanup (defer or after the message loop exits), remove the connection's subscriptions:
```go
h.mu.Lock()
delete(h.subscriptions, conn)
h.mu.Unlock()
```

### Task 4: Add subscribe/unsubscribe message handlers (hub.go HandleClient)

In the message type switch statement in HandleClient, add two new cases:

```go
case "subscribe":
    h.handleSubscribe(conn, msg)
case "unsubscribe":
    h.handleUnsubscribe(conn, msg)
```

### Task 5: Implement handleSubscribe method (hub.go)

Add this method to Hub:
```go
func (h *Hub) handleSubscribe(conn Conn, msg IncomingMessage) {
    if msg.TaskID == "" {
        h.sendError(conn, msg.ID, "task_id required for subscribe")
        return
    }
    
    h.mu.Lock()
    if subs, ok := h.subscriptions[conn]; ok {
        subs[msg.TaskID] = struct{}{}
    }
    h.mu.Unlock()
    
    // Send confirmation back to client
    response := SubscribedMessage{
        Type:   "subscribed",
        ID:     msg.ID,
        TaskID: msg.TaskID,
    }
    mu := conn.WriteLock()
    mu.Lock()
    _ = conn.WriteJSON(response)
    mu.Unlock()
}
```

### Task 6: Implement handleUnsubscribe method (hub.go)

Add this method to Hub:
```go
func (h *Hub) handleUnsubscribe(conn Conn, msg IncomingMessage) {
    if msg.TaskID == "" {
        h.sendError(conn, msg.ID, "task_id required for unsubscribe")
        return
    }
    
    h.mu.Lock()
    if subs, ok := h.subscriptions[conn]; ok {
        delete(subs, msg.TaskID)
    }
    h.mu.Unlock()
    
    // Send confirmation back to client
    response := UnsubscribedMessage{
        Type:   "unsubscribed",
        ID:     msg.ID,
        TaskID: msg.TaskID,
    }
    mu := conn.WriteLock()
    mu.Lock()
    _ = conn.WriteJSON(response)
    mu.Unlock()
}
```

### Task 7: Add BroadcastToSubscribers method (hub.go)

Add this method to Hub:
```go
// BroadcastToSubscribers sends msg only to connections subscribed to taskID.
func (h *Hub) BroadcastToSubscribers(taskID string, msg any) {
    h.mu.RLock()
    var targets []Conn
    for conn, subs := range h.subscriptions {
        if _, ok := subs[taskID]; ok {
            targets = append(targets, conn)
        }
    }
    h.mu.RUnlock()

    for _, conn := range targets {
        mu := conn.WriteLock()
        mu.Lock()
        _ = conn.WriteJSON(msg)
        mu.Unlock()
    }
}
```

### Task 8: Auto-subscribe submitter on task start (hub.go handleStart)

In the startFn closure (within handleStart), after the task is registered and the "started" message is broadcast, add auto-subscription for the submitting connection:

```go
// Auto-subscribe the requesting connection to this task's output
h.mu.Lock()
if subs, ok := h.subscriptions[conn]; ok {
    subs[taskID] = struct{}{}
}
h.mu.Unlock()
```

The conn variable is already captured by the startFn closure.

### Task 9: Route task-specific events to BroadcastToSubscribers

Identify all task-specific events and replace h.Broadcast(msg) with h.BroadcastToSubscribers(taskID, msg):

**In worker callback (workerCB):**
- OutputMessage events in onOutput → use BroadcastToSubscribers(task.id, msg)
- ExitedMessage in onWorkerExited → use BroadcastToSubscribers(task.id, msg)
- StartedMessage in startFn → use BroadcastToSubscribers(taskID, msg)
- RestartingMessage in onWorkerExited → use BroadcastToSubscribers(task.id, msg)
- ErroredMessage in onWorkerExited → use BroadcastToSubscribers(task.id, msg)

**In handleStart, handleReset, handleStop:**
- Any status update messages specific to a single task

Keep h.Broadcast() for global/response events:
- TasksMessage (response to "list" command)
- ErrorMessage (error responses to client commands)
- Any pool-wide status messages

### Task 10: Add new message types to messages.go

Add two new message types for confirmations:

```go
type SubscribedMessage struct {
    Type   string `json:"type"`   // "subscribed"
    ID     string `json:"id,omitempty"`
    TaskID string `json:"task_id"`
}

type UnsubscribedMessage struct {
    Type   string `json:"type"`   // "unsubscribed"
    ID     string `json:"id,omitempty"`
    TaskID string `json:"task_id"`
}
```

### Task 11: Update protocol documentation

Add to CLAUDE.md WebSocket protocol table:

**Client → Server** new types:
| subscribe | task_id, id | subscribe to task_id's events; auto-confirmed |
| unsubscribe | task_id, id | unsubscribe from task_id's events; auto-confirmed |

**Server → Client** new types:
| subscribed | type, task_id, id | confirms successful subscription |
| unsubscribed | type, task_id, id | confirms successful unsubscription |

### Task 12: Test subscription behavior

1. Build the binary: `make build`
2. Start the server: `./dist/sticky-overseer`
3. Create a test WebSocket client script or use wscat:
   - Connect and subscribe to a task_id
   - Start a task as another client
   - Verify the subscribed client receives task output
   - Verify an unsubscribed client does NOT receive the output
   - Verify auto-subscription: start a task and verify the submitter auto-receives output
4. Test unsubscribe: subscribe, then unsubscribe, start new output, verify no messages received
5. Test global events: send a list command and verify all connected clients receive it regardless of subscription

## Technical Requirements

File paths:
- /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/hub.go
- /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/messages.go
- /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/CLAUDE.md

Dependencies:
- sync.RWMutex (already imported)
- Hub struct and its methods
- Conn interface (WriteLock method)

Commands to test:
```bash
make build
./dist/sticky-overseer
go test -race ./...
go vet ./...
```

## Success Criteria

- Clients can send "subscribe" messages with task_id and receive confirmation
- Clients can send "unsubscribe" messages with task_id and receive confirmation
- Task-specific events (output, exited, etc.) are only sent to subscribed clients
- Client that starts a task automatically subscribes to it
- Global events (list, errors, pool updates) are still sent to all clients
- All existing tests pass (go test -race ./...)
- No race conditions detected with go test -race

## Expected Outcome

A subscription model is fully functional where:
- Clients can opt into specific tasks via subscribe/unsubscribe messages
- Task submitters auto-subscribe to tasks they start
- Multi-task deployments experience reduced network traffic (clients only get relevant events)
- All WebSocket protocol semantics remain backward compatible
- No Conn interface changes required

## Reference Information

Related job files:
- Job 1350 (hub-cleanup-db-removal): prerequisite, must be complete first
- Job 1330 (sequence numbers): should be complete for consistency

Existing methods to reference:
- Hub.Broadcast() — existing broadcast implementation to understand and extend
- Hub.sendError() — error response helper
- Handle methods in HandleClient — other message type patterns
- Worker callback patterns — how events are generated

Test patterns:
- Existing WebSocket protocol tests in the test files
- ConnectionCallbacks interface in hub.go

## Notes & Warnings

- CRITICAL: Only subscribe task-specific events to subscribed clients. Keep truly global events (list responses, errors) on Broadcast.
- The Hub.mu RWMutex protects subscriptions access. Use RLock for reads in BroadcastToSubscribers.
- Subscription cleanup is critical — always delete connection subscriptions in HandleClient cleanup to prevent memory leaks.
- Test with multiple concurrent clients to ensure no race conditions in subscription map access.
- Verify that reconnecting clients don't receive stale subscription state from previous connections (subscriptions should be per-connection, not per-client-identity).
- The auto-subscription should happen after the task is registered but it's acceptable to broadcast "started" before or after — just ensure no race where client misses the subscription update.
