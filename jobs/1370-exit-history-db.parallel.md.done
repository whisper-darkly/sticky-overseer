---
title: Add exit_history SQLite table for persistent error-window tracking across restarts
created: 2026-02-21
origin: Owner directive — exit history is the only data worth persisting. All other task state is ephemeral (start fresh on restart). Exit history enables the RetryPolicy error window to work correctly even for long-lived named tasks that were restarted.
priority: medium
complexity: medium
notes:
  - Prerequisite job 1350 (hub-cleanup-db-removal) must complete first
  - store.go should be mostly empty or contain only minimal schema setup after job 1350
  - Exit history replaces in-memory only tracking with persistent DB records
  - Named action tasks can now retain exit history across overseer restarts
  - Enables correct RetryPolicy error-window enforcement for crash-loop detection
---

Follow exactly and without stopping:

## Task: Add exit_history SQLite table for persistent error-window tracking across restarts

## Background & Context

Currently, the sticky-overseer tracks exit history in-memory only via Task.exitHistory []time.Time. When the overseer process restarts, this history is lost, meaning crash loops are not detected correctly if the overseer was restarted. For long-lived named action tasks, this is a significant correctness issue.

The owner directive states that exit history is "the only data worth persisting" — all other task state (start times, restart counts, error messages) is ephemeral and should be reset on restart. Exit history, however, enables the RetryPolicy error-window mechanism to function correctly across restarts.

This job adds an exit_history SQLite table that records non-intentional process exits with timestamps. On task startup, we load recent exits from the DB and initialize Task.exitHistory. On each non-intentional exit, we record the event. Periodic pruning prevents unbounded table growth.

## Problem Description

When the overseer restarts:
- Task records are reloaded from DB with State=active reset to State=stopped
- Task.exitHistory is populated from TaskRecord.ExitTimestamps (which is currently a JSON array in the tasks table)
- But this approach couples exit history to the tasks table, making it harder to prune without affecting task records
- If a task is deleted, its exit history is also deleted (losing crash-loop information for future similar tasks)
- The current implementation stores all exit timestamps in a single JSON column (ExitTimestamps), which is inefficient and hard to query

The goal is to separate exit history into its own table:
- exit_history(id, task_id, action, exited_at) with an index on (action, exited_at)
- Query by action (not task_id) to get exit history for a named action across all task instances
- Prune old records independently of task deletion
- Load relevant exits into Task.exitHistory when a task starts

## Implementation Plan

### Task 1: Extend store.go schema

Add exit_history table and helper functions to store.go:

1. Create the exit_history table with columns: id (PK), task_id (TEXT), action (TEXT), exited_at (TEXT)
2. Create an index on (action, exited_at) for efficient querying by action within time windows
3. Implement recordExit(db, taskID, action, exitedAt) to insert a new exit record
4. Implement loadExitHistory(db, action, since time.Time) to fetch exits for an action since a given time
5. Implement pruneExitHistory(db, before time.Time) to delete old records for maintenance
6. Keep existing TaskRecord struct but note that exitHistory will be sourced from exit_history table, not ExitTimestamps

File: store.go
Location: /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/store.go

Add after the schema creation in openDB():
```go
if _, err := db.Exec(`CREATE TABLE IF NOT EXISTS exit_history (
    id         INTEGER PRIMARY KEY AUTOINCREMENT,
    task_id    TEXT NOT NULL,
    action     TEXT NOT NULL,
    exited_at  TEXT NOT NULL
)`); err != nil {
    db.Close()
    return nil, err
}
if _, err := db.Exec(`CREATE INDEX IF NOT EXISTS idx_exit_history_lookup
    ON exit_history(action, exited_at)`); err != nil {
    db.Close()
    return nil, err
}
```

Add these new functions at the end of store.go:
```go
// recordExit records a non-intentional process exit for retry-window tracking.
// The taskID is stored for audit purposes but queries are by action.
func recordExit(db *sql.DB, taskID, action string, exitedAt time.Time) error {
    _, err := db.Exec(
        `INSERT INTO exit_history(task_id, action, exited_at) VALUES(?,?,?)`,
        taskID, action, exitedAt.UTC().Format(time.RFC3339Nano),
    )
    return err
}

// loadExitHistory returns all exit timestamps for an action within the given window.
// Pass time.Time{} as since to get all recorded exits for the action.
func loadExitHistory(db *sql.DB, action string, since time.Time) ([]time.Time, error) {
    query := `SELECT exited_at FROM exit_history WHERE action = ? AND exited_at >= ? ORDER BY exited_at ASC`
    rows, err := db.Query(query, action, since.UTC().Format(time.RFC3339Nano))
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    var result []time.Time
    for rows.Next() {
        var s string
        if err := rows.Scan(&s); err != nil {
            continue
        }
        if t, err := time.Parse(time.RFC3339Nano, s); err == nil {
            result = append(result, t)
        }
    }
    return result, rows.Err()
}

// pruneExitHistory removes exit records older than the given cutoff.
// Call periodically (e.g., hourly) to prevent unbounded table growth.
func pruneExitHistory(db *sql.DB, before time.Time) error {
    _, err := db.Exec(
        `DELETE FROM exit_history WHERE exited_at < ?`,
        before.UTC().Format(time.RFC3339Nano),
    )
    return err
}
```

### Task 2: Record exits in hub.go

In the onWorkerExited callback (search for "onWorkerExited" in hub.go):

Find the section where the worker exit is handled and non-intentional exits are detected. Add a call to recordExit if the exit was not intentional and h.db is not nil:

```go
if !intentional && h.db != nil {
    if err := recordExit(h.db, task.record.TaskID, task.record.Action, time.Now()); err != nil {
        log.Printf("exit_history: record failed: %v", err)
    }
}
```

Location: Search for "func (h *Hub) onWorkerExited" in hub.go. Find the intentional exit check and add the recordExit call right after the exit count update.

### Task 3: Load exit history on task startup

In handleStart's task creation logic (search for "handleStart" in hub.go):

After creating the Task struct (around where Task{record: r, exitHistory: ...} is set), add code to load exit history from the database:

```go
// Load recent exit history for retry-window tracking
if h.db != nil && task.record.RetryPolicy != nil && task.record.RetryPolicy.ErrorWindow > 0 {
    since := time.Now().Add(-time.Duration(task.record.RetryPolicy.ErrorWindow))
    history, err := loadExitHistory(h.db, task.record.Action, since)
    if err != nil {
        log.Printf("exit_history: load failed: %v", err)
    } else if len(history) > 0 {
        task.exitHistory = history
        task.record.ExitCount = len(history)
    }
}
```

Location: Find the code path in handleStart where a Task is created for a handleStart request. This should be after the TaskRecord is populated but before the task is added to h.tasks map.

### Task 4: Periodic pruning in newHub

In newHub() function (around where the Hub is initialized), add a background goroutine that periodically prunes old exit history:

```go
// Start background exit history pruner
go func() {
    ticker := time.NewTicker(1 * time.Hour)
    defer ticker.Stop()
    for {
        select {
        case <-ticker.C:
            if h.db != nil {
                // Prune exits older than 24 hours
                _ = pruneExitHistory(h.db, time.Now().Add(-24*time.Hour))
            }
        case <-h.shutdownCh:
            return
        }
    }
}()
```

Location: Add this at the end of newHub() function, just before the return statement.

### Task 5: Update store_test.go with exit_history tests

Replace any existing task CRUD tests with comprehensive exit_history tests. Create/update store_test.go with these test functions:

1. TestRecordExit: Verify recordExit inserts and loadExitHistory retrieves the record
2. TestLoadExitHistory_Window: Verify that loadExitHistory only returns exits within the time window
3. TestLoadExitHistory_ByAction: Verify that loadExitHistory queries by action, not task_id
4. TestPruneExitHistory: Verify that pruneExitHistory removes old records
5. TestOpenDB_SchemaCreated: Verify that openDB creates exit_history table and index

Example test structure:
```go
func TestRecordExit(t *testing.T) {
    db, cleanup := openTestDB(t)
    defer cleanup()
    
    taskID := "test-task-1"
    action := "build-docker-image"
    now := time.Now()
    
    // Record an exit
    err := recordExit(db, taskID, action, now)
    if err != nil {
        t.Fatalf("recordExit failed: %v", err)
    }
    
    // Load it back
    history, err := loadExitHistory(db, action, time.Time{})
    if err != nil {
        t.Fatalf("loadExitHistory failed: %v", err)
    }
    if len(history) != 1 {
        t.Fatalf("expected 1 exit, got %d", len(history))
    }
}

func TestLoadExitHistory_Window(t *testing.T) {
    db, cleanup := openTestDB(t)
    defer cleanup()
    
    action := "deploy-service"
    now := time.Now()
    
    // Record 3 exits at different times
    recordExit(db, "task1", action, now.Add(-3*time.Hour))
    recordExit(db, "task2", action, now.Add(-1*time.Hour))
    recordExit(db, "task3", action, now)
    
    // Query last 2 hours
    window := now.Add(-2 * time.Hour)
    history, err := loadExitHistory(db, action, window)
    if err != nil {
        t.Fatalf("loadExitHistory failed: %v", err)
    }
    if len(history) != 2 {
        t.Fatalf("expected 2 exits within window, got %d", len(history))
    }
}

func TestPruneExitHistory(t *testing.T) {
    db, cleanup := openTestDB(t)
    defer cleanup()
    
    action := "cleanup-temp-files"
    now := time.Now()
    
    // Record 2 exits
    recordExit(db, "task1", action, now.Add(-2*time.Hour))
    recordExit(db, "task2", action, now.Add(-30*time.Minute))
    
    // Prune everything older than 1 hour
    cutoff := now.Add(-1 * time.Hour)
    err := pruneExitHistory(db, cutoff)
    if err != nil {
        t.Fatalf("pruneExitHistory failed: %v", err)
    }
    
    // Verify only recent exit remains
    history, err := loadExitHistory(db, action, time.Time{})
    if err != nil {
        t.Fatalf("loadExitHistory failed: %v", err)
    }
    if len(history) != 1 {
        t.Fatalf("expected 1 exit after prune, got %d", len(history))
    }
}
```

## Technical Requirements

- File paths to modify:
  - /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/store.go
  - /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/hub.go
  - /home/mmulligan/Development/whisper-darkly-github/sticky-overseer/store_test.go

- Dependencies: Standard Go library (database/sql, time, encoding/json)

- SQLite driver: modernc.org/sqlite (already imported in store.go)

- Commands to verify:
  - go test -race ./... to run all tests
  - go vet ./... for static analysis
  - make build to compile

## Success Criteria

1. exit_history table is created with proper schema and index on first DB open
2. recordExit() successfully inserts exits into the table
3. loadExitHistory() retrieves exits by action within a time window
4. pruneExitHistory() removes old records without affecting other data
5. Task startup loads exit history from DB when RetryPolicy.ErrorWindow > 0
6. Non-intentional exits are recorded to DB before broadcast
7. Background pruner runs every hour and removes exits older than 24 hours
8. All new tests pass: TestRecordExit, TestLoadExitHistory_Window, TestLoadExitHistory_ByAction, TestPruneExitHistory
9. Existing tests continue to pass
10. go vet and go test -race produce no errors

## Expected Outcome

After completion:
- Exit history is persisted across overseer restarts in a dedicated exit_history table
- Tasks can be queried by action to retrieve crash-loop history
- RetryPolicy error-window enforcement works correctly for named actions even after overseer restart
- Old exit records are automatically pruned to prevent table bloat
- The in-memory exitHistory field is correctly initialized from DB on task creation
- All changes are backward compatible with existing task records in the DB

## Reference Information

- Related files:
  - hub.go lines 33-39: Task struct with exitHistory field
  - hub.go lines 55-86: newHub function where tasks are loaded
  - hub.go (search for "onWorkerExited"): Worker exit callback
  - hub.go (search for "handleStart"): Start task handler
  - store.go: TaskRecord struct, openDB, and existing CRUD functions
  - messages.go: RetryPolicy struct definition

- Commands to use:
  - go test -race ./... to verify all tests pass
  - go vet ./... to check for issues
  - sqlite3 to inspect the database if needed

- Architecture overview from CLAUDE.md:
  - Tasks are keyed by task_id (UUID)
  - RetryPolicy controls automatic restarts with error_window and error_threshold
  - Hub.Broadcast sends events to all connected clients
  - WAL mode and 5s busy timeout are enabled on all DB opens

## Notes & Warnings

- This job assumes job 1350 (hub-cleanup-db-removal) has completed and store.go is in a mostly empty state
- Be careful not to delete exitHistory field from Task struct — only source it from the DB instead
- The recordExit call should only happen for non-intentional exits (not user-initiated stops)
- The pruning window (24 hours) should be at least as long as the maximum configured error_window across all retry policies
- Time zone handling: Always use UTC for DB storage and parsing to avoid DST issues
- The action field in exit_history is queried more than task_id, so the index should prioritize (action, exited_at)
- Test with both in-memory (:memory:) and file-backed databases to ensure both work
